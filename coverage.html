
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>xmldom: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gogo-agent/xmldom/core.go (65.7%)</option>
				
				<option value="file1">github.com/gogo-agent/xmldom/decoder.go (86.2%)</option>
				
				<option value="file2">github.com/gogo-agent/xmldom/encoder.go (51.0%)</option>
				
				<option value="file3">github.com/gogo-agent/xmldom/escape.go (82.3%)</option>
				
				<option value="file4">github.com/gogo-agent/xmldom/marshal.go (77.4%)</option>
				
				<option value="file5">github.com/gogo-agent/xmldom/xpath.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package xmldom

import (
        "fmt"
        "reflect"
        "strings"
        sync "sync"
)

// DOMString is a string type used in the DOM.
// The DOM specification defines DOMString as a sequence of 16-bit units,
// which corresponds to UTF-16. However, for pragmatic reasons, this implementation
// uses Go's native UTF-8 strings. This avoids costly conversions at every API
// boundary. This is a documented deviation from the specification.
type DOMString string

// DOM node type constants
const (
        ELEMENT_NODE                uint16 = 1
        ATTRIBUTE_NODE              uint16 = 2
        TEXT_NODE                   uint16 = 3
        CDATA_SECTION_NODE          uint16 = 4
        ENTITY_REFERENCE_NODE       uint16 = 5
        ENTITY_NODE                 uint16 = 6
        PROCESSING_INSTRUCTION_NODE uint16 = 7
        COMMENT_NODE                uint16 = 8
        DOCUMENT_NODE               uint16 = 9
        DOCUMENT_TYPE_NODE          uint16 = 10
        DOCUMENT_FRAGMENT_NODE      uint16 = 11
        NOTATION_NODE               uint16 = 12
)

// DocumentPosition constants
const (
        DOCUMENT_POSITION_DISCONNECTED            uint16 = 0x01
        DOCUMENT_POSITION_PRECEDING               uint16 = 0x02
        DOCUMENT_POSITION_FOLLOWING               uint16 = 0x04
        DOCUMENT_POSITION_CONTAINS                uint16 = 0x08
        DOCUMENT_POSITION_CONTAINED_BY            uint16 = 0x10
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC uint16 = 0x20
)

// NodeFilter constants
const (
        FILTER_ACCEPT uint16 = 1
        FILTER_REJECT uint16 = 2
        FILTER_SKIP   uint16 = 3
)

// NodeIterator/TreeWalker whatToShow constants
const (
        SHOW_ALL                    uint32 = 0xFFFFFFFF
        SHOW_ELEMENT                uint32 = 0x00000001
        SHOW_ATTRIBUTE              uint32 = 0x00000002
        SHOW_TEXT                   uint32 = 0x00000004
        SHOW_CDATA_SECTION          uint32 = 0x00000008
        SHOW_ENTITY_REFERENCE       uint32 = 0x00000010
        SHOW_ENTITY                 uint32 = 0x00000020
        SHOW_PROCESSING_INSTRUCTION uint32 = 0x00000040
        SHOW_COMMENT                uint32 = 0x00000080
        SHOW_DOCUMENT               uint32 = 0x00000100
        SHOW_DOCUMENT_TYPE          uint32 = 0x00000200
        SHOW_DOCUMENT_FRAGMENT      uint32 = 0x00000400
        SHOW_NOTATION               uint32 = 0x00000800
)

// NodeFilter interface
type NodeFilter interface {
        AcceptNode(node Node) uint16
}

// DOM exception codes

// ===========================================================================
// Interfaces
// ===========================================================================

// Node interface represents a node in the DOM tree
type Node interface {
        NodeType() uint16
        NodeName() DOMString
        NodeValue() DOMString
        SetNodeValue(value DOMString) error
        ParentNode() Node
        ChildNodes() NodeList
        FirstChild() Node
        LastChild() Node
        PreviousSibling() Node
        NextSibling() Node
        Attributes() NamedNodeMap
        OwnerDocument() Document
        InsertBefore(newChild Node, refChild Node) (Node, error)
        ReplaceChild(newChild Node, oldChild Node) (Node, error)
        RemoveChild(oldChild Node) (Node, error)
        AppendChild(newChild Node) (Node, error)
        HasChildNodes() bool
        CloneNode(deep bool) Node
        Normalize()
        IsSupported(feature DOMString, version DOMString) bool
        NamespaceURI() DOMString
        Prefix() DOMString
        SetPrefix(prefix DOMString) error
        LocalName() DOMString
        HasAttributes() bool
        BaseURI() DOMString
        IsConnected() bool
        CompareDocumentPosition(otherNode Node) uint16
        Contains(otherNode Node) bool
        GetRootNode() Node
        IsDefaultNamespace(namespaceURI DOMString) bool
        IsEqualNode(otherNode Node) bool
        IsSameNode(otherNode Node) bool
        LookupPrefix(namespaceURI DOMString) DOMString
        LookupNamespaceURI(prefix DOMString) DOMString
        TextContent() DOMString
        SetTextContent(value DOMString)
}

// Document interface represents a document node
type Document interface {
        Node
        Doctype() DocumentType
        Implementation() DOMImplementation
        DocumentElement() Element
        CreateElement(tagName DOMString) (Element, error)
        CreateDocumentFragment() DocumentFragment
        CreateTextNode(data DOMString) Text
        CreateComment(data DOMString) Comment
        CreateCDATASection(data DOMString) (CDATASection, error)
        CreateProcessingInstruction(target, data DOMString) (ProcessingInstruction, error)
        CreateAttribute(name DOMString) (Attr, error)
        CreateEntityReference(name DOMString) (EntityReference, error)
        GetElementsByTagName(tagname DOMString) NodeList
        ImportNode(importedNode Node, deep bool) (Node, error)
        CreateElementNS(namespaceURI, qualifiedName DOMString) (Element, error)
        CreateAttributeNS(namespaceURI, qualifiedName DOMString) (Attr, error)
        GetElementsByTagNameNS(namespaceURI, localName DOMString) NodeList
        GetElementById(elementId DOMString) Element
        AdoptNode(source Node) (Node, error)
        CreateNodeIterator(root Node, whatToShow uint32, filter NodeFilter) (NodeIterator, error)
        CreateTreeWalker(root Node, whatToShow uint32, filter NodeFilter) (TreeWalker, error)
        CreateRange() Range
        NormalizeDocument()
        RenameNode(node Node, namespaceURI, qualifiedName DOMString) (Node, error)

        // XPath evaluation methods following DOM Living Standard
        CreateExpression(expression string, resolver XPathNSResolver) (XPathExpression, error)
        CreateNSResolver(nodeResolver Node) Node
        Evaluate(expression string, contextNode Node, resolver XPathNSResolver,
                resultType uint16, result XPathResult) (XPathResult, error)

        // Document properties
        URL() DOMString
        DocumentURI() DOMString
        CharacterSet() DOMString
        Charset() DOMString
        InputEncoding() DOMString
        ContentType() DOMString
}

// Element interface represents an element node
type Element interface {
        Node
        TagName() DOMString
        GetAttribute(name DOMString) DOMString
        SetAttribute(name, value DOMString) error
        RemoveAttribute(name DOMString) error
        GetAttributeNode(name DOMString) Attr
        SetAttributeNode(newAttr Attr) (Attr, error)
        RemoveAttributeNode(oldAttr Attr) (Attr, error)
        GetElementsByTagName(name DOMString) NodeList
        GetAttributeNS(namespaceURI, localName DOMString) DOMString
        SetAttributeNS(namespaceURI, qualifiedName, value DOMString) error
        RemoveAttributeNS(namespaceURI, localName DOMString) error
        GetAttributeNodeNS(namespaceURI, localName DOMString) Attr
        SetAttributeNodeNS(newAttr Attr) (Attr, error)
        GetElementsByTagNameNS(namespaceURI, localName DOMString) NodeList
        HasAttribute(name DOMString) bool
        HasAttributeNS(namespaceURI, localName DOMString) bool

        // Element manipulation methods from Living Standard (applicable to XML)
        ToggleAttribute(name DOMString, force ...bool) bool
        Remove()
        ReplaceWith(nodes ...Node) error
        Before(nodes ...Node) error
        After(nodes ...Node) error
        Prepend(nodes ...Node) error
        Append(nodes ...Node) error

        // Element DOM properties from Living Standard
        Children() ElementList // Returns live collection of child elements
        FirstElementChild() Element
        LastElementChild() Element
        PreviousElementSibling() Element
        NextElementSibling() Element
        ChildElementCount() uint32
}

// Attr interface represents an attribute node
type Attr interface {
        Node
        Name() DOMString
        Value() DOMString
        SetValue(value DOMString)
        OwnerElement() Element
}

// CharacterData interface represents character data
type CharacterData interface {
        Node
        Data() DOMString
        SetData(data DOMString) error
        Length() uint
        SubstringData(offset, count uint) (DOMString, error)
        AppendData(arg DOMString) error
        InsertData(offset uint, arg DOMString) error
        DeleteData(offset, count uint) error
        ReplaceData(offset, count uint, arg DOMString) error

        // CharacterData manipulation methods from Living Standard
        Before(nodes ...Node) error
        After(nodes ...Node) error
        ReplaceWith(nodes ...Node) error
        Remove()
}

// Text interface represents a text node
type Text interface {
        CharacterData
        SplitText(offset uint) (Text, error)
}

// Comment interface represents a comment node
type Comment interface {
        CharacterData
}

// CDATASection interface represents a CDATA section
type CDATASection interface {
        Text
}

// DocumentType interface represents a document type node
type DocumentType interface {
        Node
        Name() DOMString
        Entities() NamedNodeMap
        Notations() NamedNodeMap
        PublicId() DOMString
        SystemId() DOMString
        InternalSubset() DOMString
}

// Notation interface represents a notation node
type Notation interface {
        Node
        PublicId() DOMString
        SystemId() DOMString
}

// Entity interface represents an entity node
type Entity interface {
        Node
        PublicId() DOMString
        SystemId() DOMString
        NotationName() DOMString
}

// EntityReference interface represents an entity reference node
type EntityReference interface {
        Node
}

// ProcessingInstruction interface represents a processing instruction node
type ProcessingInstruction interface {
        Node
        Target() DOMString
        Data() DOMString
        SetData(data DOMString) error
}

// DocumentFragment interface represents a document fragment node
type DocumentFragment interface {
        Node
}

// DOMImplementation interface provides methods for operations independent of any document instance
type DOMImplementation interface {
        HasFeature(feature, version DOMString) bool
        CreateDocumentType(qualifiedName, publicId, systemId DOMString) (DocumentType, error)
        CreateDocument(namespaceURI, qualifiedName DOMString, doctype DocumentType) (Document, error)
}

// NodeList interface represents an ordered collection of nodes
type NodeList interface {
        Item(index uint) Node
        Length() uint
}

// NamedNodeMap interface represents a collection of nodes accessible by name
type NamedNodeMap interface {
        GetNamedItem(name DOMString) Node
        SetNamedItem(arg Node) (Node, error)
        RemoveNamedItem(name DOMString) (Node, error)
        Item(index uint) Node
        Length() uint
        GetNamedItemNS(namespaceURI, localName DOMString) Node
        SetNamedItemNS(arg Node) (Node, error)
        RemoveNamedItemNS(namespaceURI, localName DOMString) (Node, error)
}

// NodeIterator interface
type NodeIterator interface {
        Root() Node
        ReferenceNode() Node
        PointerBeforeReferenceNode() bool
        WhatToShow() uint32
        Filter() NodeFilter
        NextNode() (Node, error)
        PreviousNode() (Node, error)
        Detach()
}

// TreeWalker interface
type TreeWalker interface {
        Root() Node
        WhatToShow() uint32
        Filter() NodeFilter
        CurrentNode() Node
        SetCurrentNode(node Node) error
        ParentNode() Node
        FirstChild() Node
        LastChild() Node
        PreviousSibling() Node
        NextSibling() Node
        PreviousNode() Node
        NextNode() Node
}

// Range interface
type Range interface {
        StartContainer() Node
        StartOffset() uint32
        EndContainer() Node
        EndOffset() uint32
        Collapsed() bool
        CommonAncestorContainer() Node

        SetStart(node Node, offset uint32) error
        SetEnd(node Node, offset uint32) error
        SetStartBefore(node Node) error
        SetStartAfter(node Node) error
        SetEndBefore(node Node) error
        SetEndAfter(node Node) error
        Collapse(toStart bool)
        SelectNode(node Node) error
        SelectNodeContents(node Node) error

        CompareBoundaryPoints(how uint16, sourceRange Range) (int16, error)
        DeleteContents() error
        ExtractContents() (DocumentFragment, error)
        CloneContents() (DocumentFragment, error)
        InsertNode(node Node) error
        SurroundContents(newParent Node) error

        CloneRange() Range
        Detach()
        IsPointInRange(node Node, offset uint32) (bool, error)
        ComparePoint(node Node, offset uint32) (int16, error)
        IntersectsNode(node Node) bool

        ToString() string
}

// Range comparison constants
const (
        START_TO_START uint16 = 0
        START_TO_END   uint16 = 1
        END_TO_END     uint16 = 2
        END_TO_START   uint16 = 3
)

// ElementList interface - collection of Element nodes
type ElementList interface {
        Length() uint
        Item(index uint) Element
}



// ===========================================================================
// Core Implementation Types
// ===========================================================================

// DOMException represents a DOM exception as defined in the Living Standard.
type DOMException struct {
        name    DOMString
        message string
}

func (e *DOMException) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", e.name, e.message)
}</span>

// NewDOMException creates a new DOMException with the given name and message.
func NewDOMException(name DOMString, message string) *DOMException <span class="cov8" title="1">{
        return &amp;DOMException{
                name:    name,
                message: message,
        }
}</span>

// supportedFeatures defines the features and versions supported by this DOM implementation
var supportedFeatures = map[DOMString][]DOMString{
        "Core": {"2.0"},
        "XML":  {"1.0", "2.0"},
}

// liveList is a generic list implementation that can work with both Node and Element types
type liveList[T any] struct {
        items     []T                  // The cached list of items. For live lists, this is updated upon mutation.
        root      Node                 // The root node for the query that generated this list.
        filter    func(Node) bool      // The filter function to apply to the nodes.
        converter func(Node) (T, bool) // Function to convert Node to T type
        live      bool                 // True if the list is live and should be updated on mutations.
        doc       *document            // A pointer to the owner document, used to access activeNodeLists.
        update    func()               // The function to call to update the list of items.
}

// nodeList represents an ordered collection of nodes
type nodeList = liveList[Node]

// elementList represents an ordered collection of elements
type elementList = liveList[Element]

// Item returns the item at the given index in the list.
// If the index is out of bounds, it returns the zero value.
func (dl *liveList[T]) Item(index uint) T <span class="cov8" title="1">{
        var zero T
        if dl.doc != nil </span><span class="cov8" title="1">{
                dl.doc.mu.RLock()
                defer dl.doc.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">if index &gt;= uint(len(dl.items)) </span><span class="cov0" title="0">{
                return zero
        }</span>
        <span class="cov8" title="1">return dl.items[index]</span>
}

// Length returns the number of items in the list.
func (dl *liveList[T]) Length() uint <span class="cov8" title="1">{
        if dl.doc != nil </span><span class="cov8" title="1">{
                dl.doc.mu.RLock()
                defer dl.doc.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return uint(len(dl.items))</span>
}

// namedNodeMap represents a collection of nodes accessible by name
type namedNodeMap struct {
        items map[DOMString]Node
        order []DOMString
}

func NewNamedNodeMap() *namedNodeMap <span class="cov8" title="1">{
        return &amp;namedNodeMap{
                items: make(map[DOMString]Node),
                order: []DOMString{},
        }
}</span>

func (nnm *namedNodeMap) GetNamedItem(name DOMString) Node <span class="cov8" title="1">{
        return nnm.items[name]
}</span>

func (nnm *namedNodeMap) SetNamedItem(arg Node) (Node, error) <span class="cov8" title="1">{
        if arg.NodeType() != ATTRIBUTE_NODE </span><span class="cov0" title="0">{
                return nil, NewDOMException("HierarchyRequestError", "Node is not an attribute")
        }</span>
        <span class="cov8" title="1">name := arg.NodeName()
        oldArg := nnm.items[name]
        if oldArg == nil </span><span class="cov8" title="1">{
                nnm.order = append(nnm.order, name)
        }</span>
        <span class="cov8" title="1">nnm.items[name] = arg
        return oldArg, nil</span>
}

func (nnm *namedNodeMap) RemoveNamedItem(name DOMString) (Node, error) <span class="cov8" title="1">{
        node := nnm.items[name]
        if node == nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "Node not found")
        }</span>
        <span class="cov8" title="1">delete(nnm.items, name)
        for i, n := range nnm.order </span><span class="cov8" title="1">{
                if n == name </span><span class="cov8" title="1">{
                        nnm.order = append(nnm.order[:i], nnm.order[i+1:]...)
                        break</span>
                }
        }
        <span class="cov8" title="1">return node, nil</span>
}

func (nnm *namedNodeMap) Item(index uint) Node <span class="cov8" title="1">{
        if index &gt;= uint(len(nnm.order)) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return nnm.items[nnm.order[index]]</span>
}

func (nnm *namedNodeMap) Length() uint <span class="cov8" title="1">{
        return uint(len(nnm.order))
}</span>

func (nnm *namedNodeMap) GetNamedItemNS(namespaceURI, localName DOMString) Node <span class="cov8" title="1">{
        for _, node := range nnm.items </span><span class="cov8" title="1">{
                if node.NamespaceURI() == namespaceURI &amp;&amp; node.LocalName() == localName </span><span class="cov8" title="1">{
                        return node
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (nnm *namedNodeMap) SetNamedItemNS(arg Node) (Node, error) <span class="cov8" title="1">{
        if arg.NodeType() != ATTRIBUTE_NODE </span><span class="cov0" title="0">{
                return nil, NewDOMException("HierarchyRequestError", "Node is not an attribute")
        }</span>
        <span class="cov8" title="1">var oldArg Node
        var oldName DOMString
        for name, node := range nnm.items </span><span class="cov8" title="1">{
                if node.NamespaceURI() == arg.NamespaceURI() &amp;&amp; node.LocalName() == arg.LocalName() </span><span class="cov8" title="1">{
                        oldArg = node
                        oldName = name
                        break</span>
                }
        }
        <span class="cov8" title="1">if oldArg != nil </span><span class="cov8" title="1">{
                delete(nnm.items, oldName)
                for i, name := range nnm.order </span><span class="cov8" title="1">{
                        if name == oldName </span><span class="cov8" title="1">{
                                nnm.order[i] = arg.NodeName()
                                break</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                nnm.order = append(nnm.order, arg.NodeName())
        }</span>
        <span class="cov8" title="1">nnm.items[arg.NodeName()] = arg
        return oldArg, nil</span>
}

func (nnm *namedNodeMap) RemoveNamedItemNS(namespaceURI, localName DOMString) (Node, error) <span class="cov8" title="1">{
        for name, node := range nnm.items </span><span class="cov8" title="1">{
                if node.NamespaceURI() == namespaceURI &amp;&amp; node.LocalName() == localName </span><span class="cov8" title="1">{
                        delete(nnm.items, name)
                        for i, n := range nnm.order </span><span class="cov8" title="1">{
                                if n == name </span><span class="cov8" title="1">{
                                        nnm.order = append(nnm.order[:i], nnm.order[i+1:]...)
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">return node, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, NewDOMException("NotFoundError", "Node not found")</span>
}

// ===========================================================================
// Base Node Implementation
// ===========================================================================

// node represents a node in the DOM tree
type node struct {
        nodeType        uint16
        nodeName        DOMString
        nodeValue       DOMString
        parentNode      Node
        childNodes      *nodeList
        firstChild      Node
        lastChild       Node
        previousSibling Node
        nextSibling     Node
        attributes      *namedNodeMap
        ownerDocument   Document
        namespaceURI    DOMString
        prefix          DOMString
        localName       DOMString
}

func (n *node) NodeType() uint16 <span class="cov8" title="1">{
        return n.nodeType
}</span>

func (n *node) NodeName() DOMString <span class="cov8" title="1">{
        return n.nodeName
}</span>

func (n *node) NodeValue() DOMString <span class="cov8" title="1">{
        return n.nodeValue
}</span>

func (n *node) SetNodeValue(value DOMString) error <span class="cov8" title="1">{
        switch n.nodeType </span>{
        case ATTRIBUTE_NODE:<span class="cov8" title="1">
                // This is handled by Attr.SetValue, but we need to allow it here for the interface
                n.nodeValue = value
                return nil</span>
        case TEXT_NODE, COMMENT_NODE, CDATA_SECTION_NODE:<span class="cov0" title="0">
                // This is handled by CharacterData.SetData, but we need to allow it here for the interface
                n.nodeValue = value
                return nil</span>
        case PROCESSING_INSTRUCTION_NODE:<span class="cov0" title="0">
                // This is handled by ProcessingInstruction.SetData, but we need to allow it here for the interface
                n.nodeValue = value
                return nil</span>
        case ELEMENT_NODE, ENTITY_REFERENCE_NODE, ENTITY_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE, NOTATION_NODE:<span class="cov0" title="0">
                return NewDOMException("NoModificationAllowedError", "Node value is read-only for this node type")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (n *node) ParentNode() Node <span class="cov8" title="1">{
        if n.parentNode == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return n.parentNode</span>
}

func (n *node) ChildNodes() NodeList <span class="cov8" title="1">{
        if doc := n.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">if n.childNodes == nil </span><span class="cov8" title="1">{
                doc, _ := n.ownerDocument.(*document)
                nl := &amp;nodeList{
                        live: true,
                        doc:  doc,
                }
                nl.update = func() </span><span class="cov8" title="1">{
                        nodes := []Node{}
                        for child := n.firstChild; child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                                nodes = append(nodes, child)
                        }</span>
                        <span class="cov8" title="1">nl.items = nodes</span>
                }
                <span class="cov8" title="1">nl.update()

                if doc != nil </span><span class="cov8" title="1">{
                        if doc.activeNodeLists == nil </span><span class="cov8" title="1">{
                                doc.activeNodeLists = []*nodeList{}
                        }</span>
                        <span class="cov8" title="1">doc.activeNodeLists = append(doc.activeNodeLists, nl)</span>
                }
                <span class="cov8" title="1">n.childNodes = nl</span>
        }
        <span class="cov8" title="1">return n.childNodes</span>
}

func (n *node) FirstChild() Node <span class="cov8" title="1">{
        if n.firstChild == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return n.firstChild</span>
}

func (n *node) LastChild() Node <span class="cov8" title="1">{
        if n.lastChild == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return n.lastChild</span>
}

func (n *node) PreviousSibling() Node <span class="cov8" title="1">{
        if n.previousSibling == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return n.previousSibling</span>
}

func (n *node) NextSibling() Node <span class="cov8" title="1">{
        if n.nextSibling == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return n.nextSibling</span>
}

func (n *node) Attributes() NamedNodeMap <span class="cov8" title="1">{
        if doc := n.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">if n.attributes != nil </span><span class="cov8" title="1">{
                return n.attributes
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (n *node) OwnerDocument() Document <span class="cov8" title="1">{
        if n.ownerDocument == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return n.ownerDocument</span>
}

func (n *node) InsertBefore(newChild Node, refChild Node) (Node, error) <span class="cov8" title="1">{
        if newChild == nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("HierarchyRequestError", "Invalid node")
        }</span>

        // Handle self-insertion: inserting node before itself should be a no-op
        <span class="cov8" title="1">if newChild == refChild </span><span class="cov0" title="0">{
                return newChild, nil
        }</span>

        // Check document ownership
        <span class="cov8" title="1">if newChild.OwnerDocument() != n.ownerDocument &amp;&amp; n.ownerDocument != nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("WrongDocumentError", "")
        }</span>

        // HIERARCHY_REQUEST_ERR check - prevent cycles
        <span class="cov8" title="1">for ancestor := Node(n); ancestor != nil; ancestor = ancestor.ParentNode() </span><span class="cov8" title="1">{
                if ancestor == newChild </span><span class="cov0" title="0">{
                        return nil, NewDOMException("HierarchyRequestError", "Cannot insert a node as a descendant of itself")
                }</span>
        }

        // Handle DocumentFragment - insert its children instead of the fragment itself
        <span class="cov8" title="1">if newChild.NodeType() == DOCUMENT_FRAGMENT_NODE </span><span class="cov0" title="0">{
                // Collect all children of the fragment first
                var children []Node
                for child := newChild.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                        children = append(children, child)
                }</span>

                // Insert each child using internal method to avoid infinite recursion
                <span class="cov0" title="0">for _, child := range children </span><span class="cov0" title="0">{
                        // Remove from fragment first
                        if df, ok := newChild.(*documentFragment); ok </span><span class="cov0" title="0">{
                                df.removeChildInternal(child)
                        }</span> else<span class="cov0" title="0"> {
                                newChild.RemoveChild(child)
                        }</span>
                        // Insert into target parent using internal method
                        <span class="cov0" title="0">_, err := n.insertBeforeInternal(child, refChild)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // Return the fragment itself (which is now empty)
                <span class="cov0" title="0">return newChild, nil</span>
        }

        <span class="cov8" title="1">return n.insertBeforeInternal(newChild, refChild)</span>
}

// insertBeforeInternal handles the actual insertion without DocumentFragment expansion
func (n *node) insertBeforeInternal(newChild Node, refChild Node) (Node, error) <span class="cov8" title="1">{

        // Remove from current parent if exists - done internally to avoid deadlock
        if newChild.ParentNode() != nil </span><span class="cov0" title="0">{
                oldParent := newChild.ParentNode()
                oc := getInternalNode(newChild)

                // Update sibling links
                if oc.previousSibling != nil </span><span class="cov0" title="0">{
                        if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                                prevNode.nextSibling = oc.nextSibling
                        }</span>
                }
                <span class="cov0" title="0">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                        if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                                nextNode.previousSibling = oc.previousSibling
                        }</span>
                }

                // Update parent's first/last child pointers
                <span class="cov0" title="0">if op := getInternalNode(oldParent); op != nil </span><span class="cov0" title="0">{
                        if op.firstChild == newChild </span><span class="cov0" title="0">{
                                op.firstChild = oc.nextSibling
                        }</span>
                        <span class="cov0" title="0">if op.lastChild == newChild </span><span class="cov0" title="0">{
                                op.lastChild = oc.previousSibling
                        }</span>
                        // Update old parent's live NodeList if it exists
                        <span class="cov0" title="0">if op.childNodes != nil &amp;&amp; op.childNodes.update != nil </span><span class="cov0" title="0">{
                                op.childNodes.update()
                        }</span>
                }

                // Clear the removed node's parent/sibling references
                <span class="cov0" title="0">oc.parentNode = nil
                oc.previousSibling = nil
                oc.nextSibling = nil</span>
        }

        // Validate refChild
        <span class="cov8" title="1">if refChild != nil &amp;&amp; refChild.ParentNode() != Node(n) </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "refChild not found")
        }</span>

        // Get internal nodes for manipulation
        <span class="cov8" title="1">nc := getInternalNode(newChild)
        rc := getInternalNode(refChild)

        // Append or insert operation
        if refChild == nil </span><span class="cov8" title="1">{
                nc.parentNode = Node(n)
                nc.previousSibling = n.lastChild
                nc.nextSibling = nil
                if n.lastChild != nil </span><span class="cov8" title="1">{
                        if lastNode := getInternalNode(n.lastChild); lastNode != nil </span><span class="cov8" title="1">{
                                lastNode.nextSibling = newChild
                        }</span>
                }
                <span class="cov8" title="1">n.lastChild = newChild
                if n.firstChild == nil </span><span class="cov8" title="1">{
                        n.firstChild = newChild
                }</span>
        } else<span class="cov0" title="0"> { // Insert operation
                nc.parentNode = Node(n)
                nc.nextSibling = refChild
                nc.previousSibling = rc.previousSibling
                if rc.previousSibling != nil </span><span class="cov0" title="0">{
                        if prevNode := getInternalNode(rc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                                prevNode.nextSibling = newChild
                        }</span>
                } else<span class="cov0" title="0"> {
                        n.firstChild = newChild
                }</span>
                <span class="cov0" title="0">rc.previousSibling = newChild</span>
        }

        // Update live NodeList if it exists
        <span class="cov8" title="1">if n.childNodes != nil &amp;&amp; n.childNodes.update != nil </span><span class="cov8" title="1">{
                n.childNodes.update()
        }</span>
        <span class="cov8" title="1">if doc := n.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return newChild, nil</span>
}

func (n *node) ReplaceChild(newChild Node, oldChild Node) (Node, error) <span class="cov0" title="0">{
        if newChild == nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("HierarchyRequestError", "Invalid node")
        }</span>

        <span class="cov0" title="0">if oldChild.ParentNode() != n </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "")
        }</span>

        // Handle self-replacement: replacing node with itself should be a no-op
        <span class="cov0" title="0">if newChild == oldChild </span><span class="cov0" title="0">{
                return oldChild, nil
        }</span>

        // Check document ownership
        <span class="cov0" title="0">if newChild.OwnerDocument() != n.ownerDocument &amp;&amp; n.ownerDocument != nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("WrongDocumentError", "")
        }</span>

        // HIERARCHY_REQUEST_ERR check - prevent cycles
        <span class="cov0" title="0">for ancestor := Node(n); ancestor != nil; ancestor = ancestor.ParentNode() </span><span class="cov0" title="0">{
                if ancestor == newChild </span><span class="cov0" title="0">{
                        return nil, NewDOMException("HierarchyRequestError", "Cannot insert a node as a descendant of itself")
                }</span>
        }

        // Handle DocumentFragment - replace with its children
        <span class="cov0" title="0">if newChild.NodeType() == DOCUMENT_FRAGMENT_NODE </span><span class="cov0" title="0">{
                // Collect all children of the fragment first
                var children []Node
                for child := newChild.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                        children = append(children, child)
                }</span>

                <span class="cov0" title="0">if len(children) == 0 </span><span class="cov0" title="0">{
                        // Empty fragment, just remove the old child
                        return n.RemoveChild(oldChild)
                }</span>

                // Replace with first child, then insert remaining children after it
                <span class="cov0" title="0">firstChild := children[0]
                if df, ok := newChild.(*documentFragment); ok </span><span class="cov0" title="0">{
                        df.removeChildInternal(firstChild)
                }</span> else<span class="cov0" title="0"> {
                        newChild.RemoveChild(firstChild)
                }</span>
                <span class="cov0" title="0">replaced, err := n.replaceChildInternal(firstChild, oldChild)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Insert remaining children after the first one
                <span class="cov0" title="0">refChild := firstChild.NextSibling()
                for _, child := range children[1:] </span><span class="cov0" title="0">{
                        if df, ok := newChild.(*documentFragment); ok </span><span class="cov0" title="0">{
                                df.removeChildInternal(child)
                        }</span> else<span class="cov0" title="0"> {
                                newChild.RemoveChild(child)
                        }</span>
                        <span class="cov0" title="0">_, err := n.insertBeforeInternal(child, refChild)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">return replaced, nil</span>
        }

        <span class="cov0" title="0">return n.replaceChildInternal(newChild, oldChild)</span>
}

// replaceChildInternal handles the actual replacement without DocumentFragment expansion
func (n *node) replaceChildInternal(newChild Node, oldChild Node) (Node, error) <span class="cov0" title="0">{
        // Remove from current parent if exists - done internally to avoid deadlock
        if newChild.ParentNode() != nil </span><span class="cov0" title="0">{
                oldParent := newChild.ParentNode()
                oc := getInternalNode(newChild)

                // Update sibling links
                if oc.previousSibling != nil </span><span class="cov0" title="0">{
                        if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                                prevNode.nextSibling = oc.nextSibling
                        }</span>
                }
                <span class="cov0" title="0">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                        if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                                nextNode.previousSibling = oc.previousSibling
                        }</span>
                }

                // Update parent's first/last child pointers
                <span class="cov0" title="0">if op := getInternalNode(oldParent); op != nil </span><span class="cov0" title="0">{
                        if op.firstChild == newChild </span><span class="cov0" title="0">{
                                op.firstChild = oc.nextSibling
                        }</span>
                        <span class="cov0" title="0">if op.lastChild == newChild </span><span class="cov0" title="0">{
                                op.lastChild = oc.previousSibling
                        }</span>
                        // Update old parent's live NodeList if it exists
                        <span class="cov0" title="0">if op.childNodes != nil &amp;&amp; op.childNodes.update != nil </span><span class="cov0" title="0">{
                                op.childNodes.update()
                        }</span>
                }

                // Clear the removed node's parent/sibling references
                <span class="cov0" title="0">oc.parentNode = nil
                oc.previousSibling = nil
                oc.nextSibling = nil</span>
        }

        <span class="cov0" title="0">nc := getInternalNode(newChild)
        oc := getInternalNode(oldChild)

        nc.nextSibling = oc.nextSibling
        nc.previousSibling = oc.previousSibling
        nc.parentNode = n

        if oc.previousSibling != nil </span><span class="cov0" title="0">{
                if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                        prevNode.nextSibling = newChild
                }</span>
        } else<span class="cov0" title="0"> {
                n.firstChild = newChild
        }</span>

        <span class="cov0" title="0">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                        nextNode.previousSibling = newChild
                }</span>
        } else<span class="cov0" title="0"> {
                n.lastChild = newChild
        }</span>

        <span class="cov0" title="0">oc.parentNode = nil
        oc.nextSibling = nil
        oc.previousSibling = nil

        // Update live NodeList if it exists
        if n.childNodes != nil &amp;&amp; n.childNodes.update != nil </span><span class="cov0" title="0">{
                n.childNodes.update()
        }</span>
        <span class="cov0" title="0">if doc := n.OwnerDocument(); doc != nil </span><span class="cov0" title="0">{
                if d, ok := doc.(*document); ok </span><span class="cov0" title="0">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov0" title="0">return oldChild, nil</span>
}

func (n *node) RemoveChild(oldChild Node) (Node, error) <span class="cov0" title="0">{
        if oldChild.ParentNode() != n </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "")
        }</span>

        <span class="cov0" title="0">oc := getInternalNode(oldChild)

        if oc.previousSibling != nil </span><span class="cov0" title="0">{
                if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                        prevNode.nextSibling = oc.nextSibling
                }</span>
        } else<span class="cov0" title="0"> {
                n.firstChild = oc.nextSibling
        }</span>

        <span class="cov0" title="0">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                        nextNode.previousSibling = oc.previousSibling
                }</span>
        } else<span class="cov0" title="0"> {
                n.lastChild = oc.previousSibling
        }</span>

        <span class="cov0" title="0">oc.parentNode = nil
        oc.nextSibling = nil
        oc.previousSibling = nil

        // Update live NodeList if it exists
        if n.childNodes != nil &amp;&amp; n.childNodes.update != nil </span><span class="cov0" title="0">{
                n.childNodes.update()
        }</span>
        <span class="cov0" title="0">if doc := n.OwnerDocument(); doc != nil </span><span class="cov0" title="0">{
                if d, ok := doc.(*document); ok </span><span class="cov0" title="0">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov0" title="0">return oldChild, nil</span>
}

func (n *node) AppendChild(newChild Node) (Node, error) <span class="cov8" title="1">{
        return n.InsertBefore(newChild, nil)
}</span>

func (n *node) HasChildNodes() bool <span class="cov8" title="1">{
        return n.firstChild != nil
}</span>

func (n *node) CloneNode(deep bool) Node <span class="cov8" title="1">{
        clone := &amp;node{
                nodeType:      n.nodeType,
                nodeName:      n.nodeName,
                nodeValue:     n.nodeValue,
                ownerDocument: n.ownerDocument,
                namespaceURI:  n.namespaceURI,
                prefix:        n.prefix,
                localName:     n.localName,
        }

        if n.attributes != nil </span><span class="cov0" title="0">{
                clone.attributes = NewNamedNodeMap()
                for _, key := range n.attributes.order </span><span class="cov0" title="0">{
                        attr := n.attributes.items[key]
                        clonedAttr := attr.CloneNode(true)
                        clone.attributes.SetNamedItem(clonedAttr)
                }</span>
        }

        <span class="cov8" title="1">if deep </span><span class="cov8" title="1">{
                for child := n.firstChild; child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                        clone.AppendChild(child.CloneNode(true))
                }</span>
        }
        <span class="cov8" title="1">return clone</span>
}

func (n *node) Normalize() <span class="cov8" title="1">{
        // Collect children and build normalized list
        children := []Node{}
        var mergedText strings.Builder
        var hasTextNodes bool

        child := n.firstChild
        for child != nil </span><span class="cov8" title="1">{
                switch child.NodeType() </span>{
                case TEXT_NODE:<span class="cov8" title="1">
                        // Merge all text nodes, including empty ones
                        data := string(child.NodeValue())
                        mergedText.WriteString(data)
                        hasTextNodes = true</span>
                        // Don't add text nodes to children - we're merging them
                default:<span class="cov0" title="0">
                        // Non-text node: flush any pending merged text first
                        if hasTextNodes </span><span class="cov0" title="0">{
                                // Create text node with merged content (even if empty)
                                mergedContent := mergedText.String()
                                textNode := n.ownerDocument.CreateTextNode(DOMString(mergedContent))
                                children = append(children, textNode)
                                mergedText.Reset()
                                hasTextNodes = false
                        }</span>
                        // Recursively normalize element children
                        <span class="cov0" title="0">if child.HasChildNodes() </span><span class="cov0" title="0">{
                                child.Normalize()
                        }</span>
                        <span class="cov0" title="0">children = append(children, child)</span>
                }
                <span class="cov8" title="1">child = child.NextSibling()</span>
        }

        // Flush any remaining text at the end
        <span class="cov8" title="1">if hasTextNodes </span><span class="cov8" title="1">{
                mergedContent := mergedText.String()
                textNode := n.ownerDocument.CreateTextNode(DOMString(mergedContent))
                children = append(children, textNode)
        }</span>

        // Clear old child relationships first
        <span class="cov8" title="1">originalFirst := n.firstChild
        child = originalFirst
        for child != nil </span><span class="cov8" title="1">{
                next := child.NextSibling()
                if c := getInternalNode(child); c != nil </span><span class="cov8" title="1">{
                        c.parentNode = nil
                        c.previousSibling = nil
                        c.nextSibling = nil
                }</span>
                <span class="cov8" title="1">child = next</span>
        }

        // Clear and rebuild children
        <span class="cov8" title="1">n.firstChild = nil
        n.lastChild = nil

        // Re-append normalized children
        for _, child := range children </span><span class="cov8" title="1">{
                n.AppendChild(child)
        }</span>

        // Update live NodeList if it exists
        <span class="cov8" title="1">if n.childNodes != nil &amp;&amp; n.childNodes.update != nil </span><span class="cov8" title="1">{
                n.childNodes.update()
        }</span>
}

func (n *node) IsSupported(feature DOMString, version DOMString) bool <span class="cov0" title="0">{
        if versions, ok := supportedFeatures[feature]; ok </span><span class="cov0" title="0">{
                if version == "" </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">for _, v := range versions </span><span class="cov0" title="0">{
                        if v == version </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (n *node) NamespaceURI() DOMString <span class="cov8" title="1">{
        return n.namespaceURI
}</span>

func (n *node) Prefix() DOMString <span class="cov8" title="1">{
        return n.prefix
}</span>

func (n *node) SetPrefix(prefix DOMString) error <span class="cov0" title="0">{
        if prefix != "" &amp;&amp; !IsValidName(prefix) </span><span class="cov0" title="0">{
                return NewDOMException("InvalidCharacterError", "Invalid character in prefix")
        }</span>

        <span class="cov0" title="0">if n.namespaceURI == "" </span><span class="cov0" title="0">{
                return NewDOMException("NamespaceError", "Cannot set prefix for a node with no namespace URI")
        }</span>

        <span class="cov0" title="0">if prefix == "xml" &amp;&amp; n.namespaceURI != "http://www.w.org/XML/1998/namespace" </span><span class="cov0" title="0">{
                return NewDOMException("NamespaceError", "Invalid namespace URI for 'xml' prefix")
        }</span>

        <span class="cov0" title="0">if prefix == "xmlns" &amp;&amp; n.namespaceURI != "http://www.w3.org/2000/xmlns/" </span><span class="cov0" title="0">{
                return NewDOMException("NamespaceError", "Invalid namespace URI for 'xmlns' prefix")
        }</span>

        <span class="cov0" title="0">if n.nodeType == ATTRIBUTE_NODE &amp;&amp; n.NodeName() == "xmlns" </span><span class="cov0" title="0">{
                return NewDOMException("NamespaceError", "Cannot set a prefix on the 'xmlns' attribute")
        }</span>

        // Read-only check
        // This is a simplification. A more accurate check would involve checking the read-only status of the node.
        <span class="cov0" title="0">switch n.nodeType </span>{
        case ELEMENT_NODE, ATTRIBUTE_NODE:<span class="cov0" title="0"></span>
                // All good
        default:<span class="cov0" title="0">
                return NewDOMException("NoModificationAllowedError", "Cannot set prefix on this node type")</span>
        }

        <span class="cov0" title="0">n.prefix = prefix
        if n.localName != "" </span><span class="cov0" title="0">{
                if prefix != "" </span><span class="cov0" title="0">{
                        n.nodeName = prefix + ":" + n.localName
                }</span> else<span class="cov0" title="0"> {
                        n.nodeName = n.localName
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (n *node) LocalName() DOMString <span class="cov8" title="1">{
        return n.localName
}</span>

func (n *node) HasAttributes() bool <span class="cov8" title="1">{
        return n.attributes != nil &amp;&amp; n.attributes.Length() &gt; 0
}</span>

func (n *node) BaseURI() DOMString <span class="cov8" title="1">{
        // For Document nodes, the base URI is the document's address.
        if n.nodeType == DOCUMENT_NODE </span><span class="cov8" title="1">{
                // Assuming Document struct has a URL field or similar.
                // For now, return an empty string or a placeholder.
                // This will need to be properly implemented when Document URL is added.
                return ""
        }</span>

        // For other nodes, it's inherited from the parent.
        <span class="cov8" title="1">if n.parentNode != nil </span><span class="cov8" title="1">{
                return n.parentNode.BaseURI()
        }</span>

        // If no parent and not a Document, then base URI is not available.
        <span class="cov0" title="0">return ""</span> // Or a representation of null, like an empty string for DOMString
}

func (n *node) IsConnected() bool <span class="cov8" title="1">{
        // A node is connected if it has an owner document and is part of that document's tree.
        // We can check this by traversing up the parent chain.
        // If we reach the Document node and it's the ownerDocument, then it's connected.
        current := Node(n)
        for current != nil </span><span class="cov8" title="1">{
                if current.NodeType() == DOCUMENT_NODE </span><span class="cov8" title="1">{
                        return current == n.ownerDocument // Check if it's the actual owner document
                }</span>
                <span class="cov8" title="1">if parent := current.ParentNode(); parent != nil </span><span class="cov8" title="1">{
                        current = parent
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (n *node) CompareDocumentPosition(otherNode Node) uint16 <span class="cov8" title="1">{
        // 1. Same Node
        if isSameNode(Node(n), otherNode) </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Ensure both nodes are concrete *node types for internal comparison
        <span class="cov8" title="1">thisNode := getInternalNode(n)
        thatNode := getInternalNode(otherNode)

        if thisNode == nil || thatNode == nil </span><span class="cov0" title="0">{
                // One or both nodes are invalid, treat as disconnected
                return DOCUMENT_POSITION_DISCONNECTED
        }</span>

        // 2. Disconnected (different documents)
        // If one node has an owner document and the other doesn't, or they have different owner documents
        <span class="cov8" title="1">if thisNode.ownerDocument != thatNode.ownerDocument </span><span class="cov0" title="0">{
                return DOCUMENT_POSITION_DISCONNECTED
        }</span>

        // If both are not connected to a document, they are disconnected from each other
        <span class="cov8" title="1">if thisNode.ownerDocument == nil &amp;&amp; thatNode.ownerDocument == nil </span><span class="cov0" title="0">{
                return DOCUMENT_POSITION_DISCONNECTED
        }</span>

        // Check if one node contains the other
        <span class="cov8" title="1">if n.Contains(otherNode) </span><span class="cov8" title="1">{
                return DOCUMENT_POSITION_CONTAINS | DOCUMENT_POSITION_FOLLOWING
        }</span>
        <span class="cov8" title="1">if otherNode.Contains(n) </span><span class="cov8" title="1">{
                return DOCUMENT_POSITION_CONTAINED_BY | DOCUMENT_POSITION_PRECEDING
        }</span>

        // Find common ancestor and check contains/contained by
        // Build paths from each node to the root
        <span class="cov8" title="1">pathThis := []Node{}
        curr := Node(n)
        for curr != nil </span><span class="cov8" title="1">{
                pathThis = append(pathThis, curr)
                if parent := curr.ParentNode(); parent != nil </span><span class="cov8" title="1">{
                        curr = parent
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">pathThat := []Node{}
        curr = otherNode
        for curr != nil </span><span class="cov8" title="1">{
                pathThat = append(pathThat, curr)
                if parent := curr.ParentNode(); parent != nil </span><span class="cov8" title="1">{
                        curr = parent
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        // Reverse paths to go from root to node
        <span class="cov8" title="1">reversePathThis := make([]Node, len(pathThis))
        for i, node := range pathThis </span><span class="cov8" title="1">{
                reversePathThis[len(pathThis)-1-i] = node
        }</span>

        <span class="cov8" title="1">reversePathThat := make([]Node, len(pathThat))
        for i, node := range pathThat </span><span class="cov8" title="1">{
                reversePathThat[len(pathThat)-1-i] = node
        }</span>

        <span class="cov8" title="1">var commonAncestor Node
        commonAncestorIndexThis := -1
        commonAncestorIndexThat := -1

        // Find the deepest common ancestor
        for i := 0; i &lt; len(reversePathThis) &amp;&amp; i &lt; len(reversePathThat); i++ </span><span class="cov8" title="1">{
                if reversePathThis[i] == reversePathThat[i] </span><span class="cov8" title="1">{
                        commonAncestor = reversePathThis[i]
                        commonAncestorIndexThis = i
                        commonAncestorIndexThat = i
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        // If no common ancestor (and both are connected to a document, which means they are siblings of a document fragment or similar)
        // This case should ideally be covered by the ownerDocument check, but as a fallback.
        <span class="cov8" title="1">if commonAncestor == nil </span><span class="cov0" title="0">{
                return DOCUMENT_POSITION_DISCONNECTED
        }</span>

        // Determine preceding/following based on common ancestor's children
        // Get the direct children of the common ancestor that are ancestors of n and otherNode
        <span class="cov8" title="1">var ancestorOfThis, ancestorOfThat Node
        if commonAncestorIndexThis+1 &lt; len(reversePathThis) </span><span class="cov8" title="1">{
                ancestorOfThis = reversePathThis[commonAncestorIndexThis+1]
        }</span>
        <span class="cov8" title="1">if commonAncestorIndexThat+1 &lt; len(reversePathThat) </span><span class="cov8" title="1">{
                ancestorOfThat = reversePathThat[commonAncestorIndexThat+1]
        }</span>

        // Compare siblings under the common ancestor
        // Iterate through children of commonAncestor to find order
        <span class="cov8" title="1">for child := commonAncestor.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                if isSameNode(child, ancestorOfThis) </span><span class="cov8" title="1">{
                        // We found the ancestor of 'this' first, so 'this' comes before 'other'
                        // Therefore, from 'this' perspective, 'other' is FOLLOWING
                        return DOCUMENT_POSITION_FOLLOWING
                }</span>
                <span class="cov8" title="1">if isSameNode(child, ancestorOfThat) </span><span class="cov8" title="1">{
                        // We found the ancestor of 'other' first, so 'other' comes before 'this'
                        // Therefore, from 'this' perspective, 'other' is PRECEDING
                        return DOCUMENT_POSITION_PRECEDING
                }</span>
        }

        // Fallback for cases not explicitly handled (should ideally not be reached in a well-formed DOM)
        <span class="cov0" title="0">return DOCUMENT_POSITION_DISCONNECTED | DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</span>
}

func (n *node) Contains(otherNode Node) bool <span class="cov8" title="1">{
        // A node contains itself per DOM specification
        if isSameNode(Node(n), otherNode) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Traverse up the parent chain of otherNode
        <span class="cov8" title="1">current := otherNode.ParentNode()
        for current != nil </span><span class="cov8" title="1">{
                if isSameNode(Node(n), current) </span><span class="cov8" title="1">{
                        return true // n is an ancestor of otherNode
                }</span>
                <span class="cov8" title="1">current = current.ParentNode()</span>
        }
        <span class="cov8" title="1">return false</span> // n is not an ancestor of otherNode
}

func (n *node) GetRootNode() Node <span class="cov8" title="1">{
        current := Node(n)
        for parent := current.ParentNode(); parent != nil; parent = current.ParentNode() </span><span class="cov8" title="1">{
                current = parent
        }</span>
        <span class="cov8" title="1">return current</span>
}

func (n *node) IsDefaultNamespace(namespaceURI DOMString) bool <span class="cov8" title="1">{
        // If the node is an Attr node, it does not have a default namespace.
        if n.NodeType() == ATTRIBUTE_NODE </span><span class="cov0" title="0">{
                return false
        }</span>

        // If the node has a namespace URI and it matches the given namespaceURI,
        // and it has no prefix, then it's the default namespace.
        <span class="cov8" title="1">if n.NamespaceURI() == namespaceURI &amp;&amp; n.Prefix() == "" </span><span class="cov8" title="1">{
                return true
        }</span>

        // For other nodes, check the parent.
        <span class="cov0" title="0">if n.ParentNode() != nil </span><span class="cov0" title="0">{
                return n.ParentNode().IsDefaultNamespace(namespaceURI)
        }</span>

        // If no parent and no matching namespace, it's not the default.
        <span class="cov0" title="0">return false</span>
}

func (n *node) IsEqualNode(otherNode Node) bool <span class="cov8" title="1">{
        // If both are nil, they are equal. If one is nil and other is not, they are not equal.
        if n == nil &amp;&amp; otherNode == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if n == nil || otherNode == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 1. Node type must be the same
        <span class="cov8" title="1">if n.NodeType() != otherNode.NodeType() </span><span class="cov0" title="0">{
                return false
        }</span>

        // 2. Node name, local name, namespace URI, prefix, and node value must be the same
        <span class="cov8" title="1">if n.NodeName() != otherNode.NodeName() ||
                n.LocalName() != otherNode.LocalName() ||
                n.NamespaceURI() != otherNode.NamespaceURI() ||
                n.Prefix() != otherNode.Prefix() ||
                n.NodeValue() != otherNode.NodeValue() </span><span class="cov0" title="0">{
                return false
        }</span>

        // 3. Attributes must be the same (for Element and Attr nodes)
        <span class="cov8" title="1">if n.NodeType() == ELEMENT_NODE || n.NodeType() == ATTRIBUTE_NODE </span><span class="cov8" title="1">{
                if n.Attributes() == nil &amp;&amp; otherNode.Attributes() != nil ||
                        n.Attributes() != nil &amp;&amp; otherNode.Attributes() == nil ||
                        (n.Attributes() != nil &amp;&amp; otherNode.Attributes() != nil &amp;&amp; n.Attributes().Length() != otherNode.Attributes().Length()) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if n.Attributes() != nil </span><span class="cov8" title="1">{
                        for i := uint(0); i &lt; n.Attributes().Length(); i++ </span><span class="cov0" title="0">{
                                attr1 := n.Attributes().Item(i).(Attr)
                                attr2 := otherNode.Attributes().GetNamedItemNS(attr1.NamespaceURI(), attr1.LocalName()).(Attr)
                                if attr2 == nil || !attr1.IsEqualNode(attr2) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }
        }

        // 4. Children must be the same (recursively)
        <span class="cov8" title="1">if n.HasChildNodes() != otherNode.HasChildNodes() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">if n.HasChildNodes() </span><span class="cov0" title="0">{
                child1 := n.FirstChild()
                child2 := otherNode.FirstChild()

                for child1 != nil &amp;&amp; child2 != nil </span><span class="cov0" title="0">{
                        if !child1.IsEqualNode(child2) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">child1 = child1.NextSibling()
                        child2 = child2.NextSibling()</span>
                }

                // If one has more children than the other
                <span class="cov0" title="0">if child1 != nil || child2 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (n *node) IsSameNode(otherNode Node) bool <span class="cov8" title="1">{
        return isSameNode(Node(n), otherNode)
}</span>

func (n *node) LookupPrefix(namespaceURI DOMString) DOMString <span class="cov8" title="1">{
        if namespaceURI == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // If this node is an element, check its attributes for namespace declarations
        <span class="cov8" title="1">if n.NodeType() == ELEMENT_NODE &amp;&amp; n.attributes != nil </span><span class="cov8" title="1">{
                for i := uint(0); i &lt; n.attributes.Length(); i++ </span><span class="cov0" title="0">{
                        attr := n.attributes.Item(i).(Attr)
                        if attr.Prefix() == "xmlns" &amp;&amp; attr.NodeValue() == namespaceURI </span><span class="cov0" title="0">{
                                return attr.LocalName()
                        }</span> else<span class="cov0" title="0"> if attr.NodeName() == "xmlns" &amp;&amp; attr.NodeValue() == namespaceURI </span><span class="cov0" title="0">{
                                // Default namespace declaration
                                return "" // Default namespace has no prefix
                        }</span>
                }
        }

        // If this node has a prefix and its namespace URI matches, return its prefix
        <span class="cov8" title="1">if n.Prefix() != "" &amp;&amp; n.NamespaceURI() == namespaceURI </span><span class="cov8" title="1">{
                return n.Prefix()
        }</span>

        // Recursively check parent
        <span class="cov8" title="1">if n.ParentNode() != nil </span><span class="cov8" title="1">{
                return n.ParentNode().LookupPrefix(namespaceURI)
        }</span>

        <span class="cov8" title="1">return ""</span> // No prefix found
}

func (n *node) LookupNamespaceURI(prefix DOMString) DOMString <span class="cov8" title="1">{
        // If this node is an element, check its attributes for namespace declarations
        if n.NodeType() == ELEMENT_NODE &amp;&amp; n.attributes != nil </span><span class="cov8" title="1">{
                for i := uint(0); i &lt; n.attributes.Length(); i++ </span><span class="cov0" title="0">{
                        attr := n.attributes.Item(i).(Attr)
                        if attr.Prefix() == "xmlns" &amp;&amp; attr.LocalName() == prefix </span><span class="cov0" title="0">{
                                return attr.NodeValue()
                        }</span> else<span class="cov0" title="0"> if prefix == "" &amp;&amp; attr.NodeName() == "xmlns" </span><span class="cov0" title="0">{
                                // Default namespace declaration
                                return attr.NodeValue()
                        }</span>
                }
        }

        // If this node has the prefix and a namespace URI, return its namespace URI
        <span class="cov8" title="1">if n.Prefix() == prefix &amp;&amp; n.NamespaceURI() != "" </span><span class="cov8" title="1">{
                return n.NamespaceURI()
        }</span>

        // Recursively check parent
        <span class="cov8" title="1">if n.ParentNode() != nil </span><span class="cov8" title="1">{
                return n.ParentNode().LookupNamespaceURI(prefix)
        }</span>

        <span class="cov8" title="1">return ""</span> // No namespace URI found
}

func (n *node) TextContent() DOMString <span class="cov8" title="1">{
        var buf strings.Builder
        visited := make(map[Node]bool)
        var traverse func(node Node)
        traverse = func(node Node) </span><span class="cov8" title="1">{
                if node == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if visited[node] </span><span class="cov0" title="0">{
                        return // Prevent infinite loops
                }</span>
                <span class="cov8" title="1">visited[node] = true

                switch node.NodeType() </span>{
                case TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE, PROCESSING_INSTRUCTION_NODE:<span class="cov8" title="1">
                        buf.WriteString(string(node.NodeValue()))</span>
                case ELEMENT_NODE, DOCUMENT_FRAGMENT_NODE:<span class="cov8" title="1">
                        child := node.FirstChild()
                        for child != nil </span><span class="cov8" title="1">{
                                traverse(child)
                                child = child.NextSibling()
                        }</span>
                }
        }
        <span class="cov8" title="1">traverse(n)
        return DOMString(buf.String())</span>
}

func (n *node) SetTextContent(value DOMString) <span class="cov8" title="1">{
        // Direct removal of children to avoid RemoveChild complexity
        n.firstChild = nil
        n.lastChild = nil

        // Update child nodes live list if it exists
        if n.childNodes != nil &amp;&amp; n.childNodes.update != nil </span><span class="cov0" title="0">{
                n.childNodes.update()
        }</span>

        // If value is not empty, create a new text node and append it
        <span class="cov8" title="1">if value != "" </span><span class="cov8" title="1">{
                textNode := n.OwnerDocument().CreateTextNode(value)
                n.AppendChild(textNode)
        }</span>
}

// ===========================================================================
// Document Implementation
// ===========================================================================

// document represents a document node
type document struct {
        node
        doctype         DocumentType
        implementation  DOMImplementation
        documentElement Element
        idMap           map[DOMString]Element
        activeNodeLists []*nodeList
        mu              sync.RWMutex // Mutex for protecting concurrent access to the DOM

        // Document properties
        url          DOMString
        documentURI  DOMString
        characterSet DOMString
        contentType  DOMString
}

func (d *document) InsertBefore(newChild Node, refChild Node) (Node, error) <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()
        result, err := d.node.InsertBefore(newChild, refChild)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Fix the parent reference to be the document interface
        <span class="cov8" title="1">if nc := getInternalNode(newChild); nc != nil </span><span class="cov8" title="1">{
                nc.parentNode = d
        }</span>
        
        // Set as document element if this is the first element child and no document element is set
        <span class="cov8" title="1">if newChild.NodeType() == ELEMENT_NODE &amp;&amp; d.documentElement == nil </span><span class="cov8" title="1">{
                if elem, ok := newChild.(Element); ok </span><span class="cov8" title="1">{
                        d.documentElement = elem
                }</span>
        }
        
        <span class="cov8" title="1">return result, nil</span>
}

func (d *document) AppendChild(newChild Node) (Node, error) <span class="cov8" title="1">{
        return d.InsertBefore(newChild, nil)
}</span>

func (d *document) RemoveChild(oldChild Node) (Node, error) <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()
        parent := oldChild.ParentNode()
        if parent == nil || parent != Node(d) </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "")
        }</span>

        <span class="cov8" title="1">oc := getInternalNode(oldChild)

        if oc.previousSibling != nil </span><span class="cov0" title="0">{
                if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                        prevNode.nextSibling = oc.nextSibling
                }</span>
        } else<span class="cov8" title="1"> {
                d.firstChild = oc.nextSibling
        }</span>

        <span class="cov8" title="1">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                        nextNode.previousSibling = oc.previousSibling
                }</span>
        } else<span class="cov8" title="1"> {
                d.lastChild = oc.previousSibling
        }</span>

        <span class="cov8" title="1">oc.parentNode = nil
        oc.nextSibling = nil
        oc.previousSibling = nil

        // Update live NodeList if it exists
        if d.childNodes != nil &amp;&amp; d.childNodes.update != nil </span><span class="cov0" title="0">{
                d.childNodes.update()
        }</span>
        <span class="cov8" title="1">return oldChild, nil</span>
}

func (d *document) Doctype() DocumentType <span class="cov8" title="1">{
        if d.doctype != nil </span><span class="cov8" title="1">{
                return d.doctype
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *document) Implementation() DOMImplementation <span class="cov8" title="1">{
        return d.implementation
}</span>

func (d *document) DocumentElement() Element <span class="cov8" title="1">{
        if d.documentElement != nil </span><span class="cov8" title="1">{
                return d.documentElement
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *document) CreateElement(tagName DOMString) (Element, error) <span class="cov8" title="1">{
        if !IsValidName(tagName) </span><span class="cov8" title="1">{
                return nil, NewDOMException("InvalidCharacterError", "Invalid character in element name")
        }</span>
        <span class="cov8" title="1">elem := &amp;element{
                node: node{
                        nodeType:      ELEMENT_NODE,
                        nodeName:      tagName,
                        ownerDocument: d,
                        attributes:    NewNamedNodeMap(),
                },
        }
        return elem, nil</span>
}

func (d *document) CreateDocumentFragment() DocumentFragment <span class="cov8" title="1">{
        return &amp;documentFragment{
                node: node{
                        nodeType:      DOCUMENT_FRAGMENT_NODE,
                        nodeName:      "#document-fragment",
                        ownerDocument: d,
                },
        }
}</span>

func (d *document) CreateTextNode(data DOMString) Text <span class="cov8" title="1">{
        return &amp;text{
                characterData: characterData{
                        node: node{
                                nodeType:      TEXT_NODE,
                                nodeName:      "#text",
                                nodeValue:     data,
                                ownerDocument: d,
                        },
                },
        }
}</span>

func (d *document) CreateComment(data DOMString) Comment <span class="cov8" title="1">{
        return &amp;comment{
                characterData: characterData{
                        node: node{
                                nodeType:      COMMENT_NODE,
                                nodeName:      "#comment",
                                nodeValue:     data,
                                ownerDocument: d,
                        },
                },
        }
}</span>

func (d *document) CreateCDATASection(data DOMString) (CDATASection, error) <span class="cov8" title="1">{
        return &amp;cdataSection{
                text: text{
                        characterData: characterData{
                                node: node{
                                        nodeType:      CDATA_SECTION_NODE,
                                        nodeName:      "#cdata-section",
                                        nodeValue:     data,
                                        ownerDocument: d,
                                },
                        },
                },
        }, nil
}</span>

func (d *document) CreateProcessingInstruction(target, data DOMString) (ProcessingInstruction, error) <span class="cov8" title="1">{
        if !IsValidName(target) || strings.EqualFold(string(target), "xml") </span><span class="cov0" title="0">{
                return nil, NewDOMException("InvalidCharacterError", "Invalid processing instruction target")
        }</span>
        <span class="cov8" title="1">return &amp;processingInstruction{
                node: node{
                        nodeType:      PROCESSING_INSTRUCTION_NODE,
                        nodeName:      target,
                        nodeValue:     data,
                        ownerDocument: d,
                },
                target: target,
                data:   data,
        }, nil</span>
}

func (d *document) CreateAttribute(name DOMString) (Attr, error) <span class="cov8" title="1">{
        if !IsValidName(name) </span><span class="cov8" title="1">{
                return nil, NewDOMException("InvalidCharacterError", "Invalid character in attribute name")
        }</span>
        <span class="cov8" title="1">return &amp;attr{
                node: node{
                        nodeType:      ATTRIBUTE_NODE,
                        nodeName:      name,
                        ownerDocument: d,
                },
        }, nil</span>
}

func (d *document) CreateEntityReference(name DOMString) (EntityReference, error) <span class="cov0" title="0">{
        return &amp;entityReference{
                node: node{
                        nodeType:      ENTITY_REFERENCE_NODE,
                        nodeName:      name,
                        ownerDocument: d,
                },
        }, nil
}</span>

func (d *document) GetElementsByTagName(tagname DOMString) NodeList <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        nl := &amp;nodeList{
                root: d,
                filter: func(n Node) bool </span><span class="cov8" title="1">{
                        return n.NodeType() == ELEMENT_NODE &amp;&amp; (tagname == "*" || n.NodeName() == tagname)
                }</span>,
                live: true,
                doc:  d,
        }
        <span class="cov8" title="1">nl.update = func() </span><span class="cov8" title="1">{
                nodes := []Node{}
                var helper func(Node)
                helper = func(n Node) </span><span class="cov8" title="1">{
                        if n == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if nl.filter(n) </span><span class="cov8" title="1">{
                                nodes = append(nodes, n)
                        }</span>
                        <span class="cov8" title="1">for child := n.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                                helper(child)
                        }</span>
                }
                <span class="cov8" title="1">helper(nl.root)
                nl.items = nodes</span>
        }
        <span class="cov8" title="1">nl.update() // initial population
        if d.activeNodeLists == nil </span><span class="cov8" title="1">{
                d.activeNodeLists = []*nodeList{}
        }</span>
        <span class="cov8" title="1">d.activeNodeLists = append(d.activeNodeLists, nl)
        return nl</span>
}

func (d *document) getElementsByTagNameHelper(n Node, tagname DOMString, result *[]Node) <span class="cov0" title="0">{
        internal := getInternalNode(n)
        if internal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for child := internal.firstChild; child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                if child.NodeType() == ELEMENT_NODE </span><span class="cov0" title="0">{
                        if tagname == "*" || child.NodeName() == tagname </span><span class="cov0" title="0">{
                                *result = append(*result, child)
                        }</span>
                        <span class="cov0" title="0">d.getElementsByTagNameHelper(child, tagname, result)</span>
                }
        }
}

func (d *document) ImportNode(importedNode Node, deep bool) (Node, error) <span class="cov8" title="1">{
        if importedNode == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Clone the node
        <span class="cov8" title="1">newNode := importedNode.CloneNode(deep)

        // Set the owner document for the new node and its children
        var setOwner func(Node)
        setOwner = func(n Node) </span><span class="cov8" title="1">{
                if internalNode := getInternalNode(n); internalNode != nil </span><span class="cov8" title="1">{
                        internalNode.ownerDocument = d
                }</span>
                // Recursively set owner for children
                <span class="cov8" title="1">for child := n.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        setOwner(child)
                }</span>
                // Recursively set owner for attributes
                <span class="cov8" title="1">if n.Attributes() != nil </span><span class="cov8" title="1">{
                        for i := uint(0); i &lt; n.Attributes().Length(); i++ </span><span class="cov8" title="1">{
                                setOwner(n.Attributes().Item(i))
                        }</span>
                }
        }

        <span class="cov8" title="1">setOwner(newNode)

        return newNode, nil</span>
}

func (d *document) CreateElementNS(namespaceURI, qualifiedName DOMString) (Element, error) <span class="cov8" title="1">{
        if !IsValidName(qualifiedName) </span><span class="cov8" title="1">{
                return nil, NewDOMException("InvalidCharacterError", "Invalid character in element qualified name")
        }</span>
        
        // Reject reserved namespace URIs
        <span class="cov8" title="1">if namespaceURI == "http://www.w3.org/2000/xmlns/" || namespaceURI == "http://www.w3.org/XML/1998/namespace" </span><span class="cov8" title="1">{
                return nil, NewDOMException("NamespaceError", "Reserved namespace URI")
        }</span>
        
        <span class="cov8" title="1">prefix, localName := parseQualifiedName(qualifiedName)
        return &amp;element{
                node: node{
                        nodeType:      ELEMENT_NODE,
                        nodeName:      qualifiedName,
                        ownerDocument: d,
                        namespaceURI:  namespaceURI,
                        prefix:        prefix,
                        localName:     localName,
                        attributes:    NewNamedNodeMap(),
                },
        }, nil</span>
}

func (d *document) CreateAttributeNS(namespaceURI, qualifiedName DOMString) (Attr, error) <span class="cov8" title="1">{
        if !IsValidName(qualifiedName) </span><span class="cov0" title="0">{
                return nil, NewDOMException("InvalidCharacterError", "Invalid character in attribute qualified name")
        }</span>
        <span class="cov8" title="1">prefix, localName := parseQualifiedName(qualifiedName)
        return &amp;attr{
                node: node{
                        nodeType:      ATTRIBUTE_NODE,
                        nodeName:      qualifiedName,
                        ownerDocument: d,
                        namespaceURI:  namespaceURI,
                        prefix:        prefix,
                        localName:     localName,
                },
        }, nil</span>
}

func (d *document) GetElementsByTagNameNS(namespaceURI, localName DOMString) NodeList <span class="cov8" title="1">{
        nl := &amp;nodeList{
                root: d,
                filter: func(n Node) bool </span><span class="cov8" title="1">{
                        return n.NodeType() == ELEMENT_NODE &amp;&amp;
                                (namespaceURI == "*" || n.NamespaceURI() == namespaceURI) &amp;&amp;
                                (localName == "*" || n.LocalName() == localName)
                }</span>,
                live: true,
                doc:  d,
        }
        <span class="cov8" title="1">nl.update = func() </span><span class="cov8" title="1">{
                nodes := []Node{}
                var helper func(Node)
                helper = func(n Node) </span><span class="cov8" title="1">{
                        if n == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if nl.filter(n) </span><span class="cov8" title="1">{
                                nodes = append(nodes, n)
                        }</span>
                        <span class="cov8" title="1">for child := n.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                                helper(child)
                        }</span>
                }
                <span class="cov8" title="1">helper(nl.root)
                nl.items = nodes</span>
        }
        <span class="cov8" title="1">nl.update() // initial population
        if d.activeNodeLists == nil </span><span class="cov8" title="1">{
                d.activeNodeLists = []*nodeList{}
        }</span>
        <span class="cov8" title="1">d.activeNodeLists = append(d.activeNodeLists, nl)
        return nl</span>
}

func (d *document) getElementsByTagNameNSHelper(n Node, namespaceURI, localName DOMString, result *[]Node) <span class="cov0" title="0">{
        internal := getInternalNode(n)
        if internal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for child := internal.firstChild; child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                if child.NodeType() == ELEMENT_NODE </span><span class="cov0" title="0">{
                        if (namespaceURI == "*" || child.NamespaceURI() == namespaceURI) &amp;&amp;
                                (localName == "*" || child.LocalName() == localName) </span><span class="cov0" title="0">{
                                *result = append(*result, child)
                        }</span>
                        <span class="cov0" title="0">d.getElementsByTagNameNSHelper(child, namespaceURI, localName, result)</span>
                }
        }
}

func (d *document) GetElementById(elementId DOMString) Element <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        if d.idMap != nil </span><span class="cov8" title="1">{
                if elem := d.idMap[elementId]; elem != nil </span><span class="cov8" title="1">{
                        return elem
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *document) AdoptNode(source Node) (Node, error) <span class="cov8" title="1">{
        if source == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // If the source node has a parent, remove it from its parent.
        <span class="cov8" title="1">if source.ParentNode() != nil </span><span class="cov8" title="1">{
                // If the source is the document element of its owner document, clear the documentElement field
                if sourceOwner := source.OwnerDocument(); sourceOwner != nil </span><span class="cov8" title="1">{
                        if ownerDoc, ok := sourceOwner.(*document); ok </span><span class="cov8" title="1">{
                                if ownerDoc.documentElement != nil &amp;&amp; ownerDoc.documentElement == source </span><span class="cov8" title="1">{
                                        ownerDoc.documentElement = nil
                                }</span>
                        }
                }
                <span class="cov8" title="1">source.ParentNode().RemoveChild(source)</span>
        }

        // Set the owner document for the source node and its children (including attributes).
        <span class="cov8" title="1">var setOwner func(Node)
        setOwner = func(n Node) </span><span class="cov8" title="1">{
                if internalNode := getInternalNode(n); internalNode != nil </span><span class="cov8" title="1">{
                        internalNode.ownerDocument = d
                }</span>
                // Recursively set owner for children
                <span class="cov8" title="1">for child := n.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                        setOwner(child)
                }</span>
                // Recursively set owner for attributes
                <span class="cov8" title="1">if n.Attributes() != nil </span><span class="cov8" title="1">{
                        for i := uint(0); i &lt; n.Attributes().Length(); i++ </span><span class="cov0" title="0">{
                                setOwner(n.Attributes().Item(i))
                        }</span>
                }
        }

        <span class="cov8" title="1">setOwner(source)

        return source, nil</span>
}

// nodeIterator implements the NodeIterator interface.
type nodeIterator struct {
        root                       Node
        referenceNode              Node
        pointerBeforeReferenceNode bool
        whatToShow                 uint32
        filter                     NodeFilter
        active                     bool // Indicates if the iterator is still active
}

func (ni *nodeIterator) Root() Node <span class="cov8" title="1">{
        return ni.root
}</span>

func (ni *nodeIterator) ReferenceNode() Node <span class="cov0" title="0">{
        return ni.referenceNode
}</span>

func (ni *nodeIterator) PointerBeforeReferenceNode() bool <span class="cov0" title="0">{
        return ni.pointerBeforeReferenceNode
}</span>

func (ni *nodeIterator) WhatToShow() uint32 <span class="cov0" title="0">{
        return ni.whatToShow
}</span>

func (ni *nodeIterator) Filter() NodeFilter <span class="cov0" title="0">{
        return ni.filter
}</span>

func (ni *nodeIterator) Detach() <span class="cov8" title="1">{
        ni.active = false
}</span>

func (ni *nodeIterator) NextNode() (Node, error) <span class="cov8" title="1">{
        if !ni.active </span><span class="cov8" title="1">{
                return nil, NewDOMException("InvalidStateError", "NodeIterator is detached")
        }</span>

        // Acquire read lock on the document
        <span class="cov8" title="1">if doc := ni.root.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }

        <span class="cov8" title="1">var candidate Node
        if ni.pointerBeforeReferenceNode </span><span class="cov8" title="1">{
                candidate = ni.referenceNode
                ni.pointerBeforeReferenceNode = false
        }</span> else<span class="cov8" title="1"> {
                candidate = ni.getNextCandidate(ni.referenceNode)
        }</span>

        <span class="cov8" title="1">for candidate != nil </span><span class="cov8" title="1">{
                // Check if candidate is within the root's subtree
                if !ni.isInSubtree(candidate) </span><span class="cov0" title="0">{
                        candidate = ni.getNextCandidate(candidate)
                        continue</span>
                }

                // Apply whatToShow and filter
                <span class="cov8" title="1">if ni.acceptNode(candidate) </span><span class="cov8" title="1">{
                        ni.referenceNode = candidate
                        return candidate, nil
                }</span>

                <span class="cov0" title="0">candidate = ni.getNextCandidate(candidate)</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func (ni *nodeIterator) PreviousNode() (Node, error) <span class="cov8" title="1">{
        if !ni.active </span><span class="cov0" title="0">{
                return nil, NewDOMException("InvalidStateError", "NodeIterator is detached")
        }</span>

        // Acquire read lock on the document
        <span class="cov8" title="1">if doc := ni.root.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }

        <span class="cov8" title="1">var candidate Node
        if !ni.pointerBeforeReferenceNode </span><span class="cov8" title="1">{
                // Return the current reference node first, then set pointer before it
                if ni.acceptNode(ni.referenceNode) </span><span class="cov8" title="1">{
                        ni.pointerBeforeReferenceNode = true
                        return ni.referenceNode, nil
                }</span>
                <span class="cov0" title="0">candidate = ni.getPreviousCandidate(ni.referenceNode)
                ni.pointerBeforeReferenceNode = true</span>
        } else<span class="cov8" title="1"> {
                candidate = ni.getPreviousCandidate(ni.referenceNode)
        }</span>

        <span class="cov8" title="1">for candidate != nil </span><span class="cov8" title="1">{
                // Check if candidate is within the root's subtree
                if !ni.isInSubtree(candidate) </span><span class="cov8" title="1">{
                        candidate = ni.getPreviousCandidate(candidate)
                        continue</span>
                }

                // Apply whatToShow and filter
                <span class="cov8" title="1">if ni.acceptNode(candidate) </span><span class="cov8" title="1">{
                        ni.referenceNode = candidate
                        return candidate, nil
                }</span>

                <span class="cov0" title="0">candidate = ni.getPreviousCandidate(candidate)</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func (ni *nodeIterator) getNextCandidate(current Node) Node <span class="cov8" title="1">{
        if current == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try first child
        <span class="cov8" title="1">if current.FirstChild() != nil </span><span class="cov8" title="1">{
                return current.FirstChild()
        }</span>

        // Try next sibling
        <span class="cov8" title="1">if current.NextSibling() != nil </span><span class="cov8" title="1">{
                return current.NextSibling()
        }</span>

        // Go up and try next sibling of ancestors
        <span class="cov8" title="1">parent := current.ParentNode()
        for parent != nil &amp;&amp; parent != ni.root </span><span class="cov8" title="1">{
                if parent.NextSibling() != nil </span><span class="cov0" title="0">{
                        return parent.NextSibling()
                }</span>
                <span class="cov8" title="1">parent = parent.ParentNode()</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (ni *nodeIterator) getPreviousCandidate(current Node) Node <span class="cov8" title="1">{
        // Try previous sibling's last descendant
        if current.PreviousSibling() != nil </span><span class="cov8" title="1">{
                candidate := current.PreviousSibling()
                for candidate.LastChild() != nil </span><span class="cov0" title="0">{
                        candidate = candidate.LastChild()
                }</span>
                <span class="cov8" title="1">return candidate</span>
        }

        // Try parent (including root)
        <span class="cov8" title="1">if current.ParentNode() != nil </span><span class="cov8" title="1">{
                return current.ParentNode()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (ni *nodeIterator) isInSubtree(node Node) bool <span class="cov8" title="1">{
        if isSameNode(node, ni.root) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return ni.root.Contains(node)</span>
}

func (ni *nodeIterator) acceptNode(node Node) bool <span class="cov8" title="1">{
        // Check whatToShow
        if ni.whatToShow != 0xFFFFFFFF </span><span class="cov0" title="0">{
                // NodeType values are 1-indexed, so we need to shift by (NodeType - 1)
                mask := uint32(1 &lt;&lt; (node.NodeType() - 1))
                if (ni.whatToShow &amp; mask) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check filter
        <span class="cov8" title="1">if ni.filter != nil </span><span class="cov0" title="0">{
                return ni.filter.AcceptNode(node) == FILTER_ACCEPT
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (d *document) CreateNodeIterator(root Node, whatToShow uint32, filter NodeFilter) (NodeIterator, error) <span class="cov8" title="1">{
        // Acquire read lock on the document
        d.mu.RLock()
        defer d.mu.RUnlock()

        // The root must be a Node within the document.
        if root == nil || (root.OwnerDocument() != d &amp;&amp; root.NodeType() != DOCUMENT_NODE) </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "The root is not a node in this document.")
        }</span>

        <span class="cov8" title="1">ni := &amp;nodeIterator{
                root:                       root,
                referenceNode:              root,
                pointerBeforeReferenceNode: true,
                whatToShow:                 whatToShow,
                filter:                     filter,
                active:                     true,
        }
        return ni, nil</span>
}

// treeWalker implements the TreeWalker interface.
type treeWalker struct {
        root        Node
        whatToShow  uint32
        filter      NodeFilter
        currentNode Node
}

func (tw *treeWalker) Root() Node <span class="cov0" title="0">{
        return tw.root
}</span>

func (tw *treeWalker) WhatToShow() uint32 <span class="cov0" title="0">{
        return tw.whatToShow
}</span>

func (tw *treeWalker) Filter() NodeFilter <span class="cov0" title="0">{
        return tw.filter
}</span>

func (tw *treeWalker) CurrentNode() Node <span class="cov8" title="1">{
        return tw.currentNode
}</span>

func (tw *treeWalker) SetCurrentNode(node Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return NewDOMException("NotSupportedError", "CurrentNode cannot be null")
        }</span>
        <span class="cov8" title="1">tw.currentNode = node
        return nil</span>
}

func (tw *treeWalker) acceptNode(node Node) uint16 <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return FILTER_REJECT
        }</span>

        // Check whatToShow
        <span class="cov8" title="1">if tw.whatToShow != 0xFFFFFFFF </span><span class="cov8" title="1">{
                // NodeType values are 1-indexed, so we need to shift by (NodeType - 1)
                mask := uint32(1 &lt;&lt; (node.NodeType() - 1))
                if (tw.whatToShow &amp; mask) == 0 </span><span class="cov0" title="0">{
                        return FILTER_SKIP
                }</span>
        }

        // Check filter
        <span class="cov8" title="1">if tw.filter != nil </span><span class="cov0" title="0">{
                return tw.filter.AcceptNode(node)
        }</span>

        <span class="cov8" title="1">return FILTER_ACCEPT</span>
}

func (tw *treeWalker) ParentNode() Node <span class="cov8" title="1">{
        node := tw.currentNode
        for node != nil &amp;&amp; node != tw.root </span><span class="cov8" title="1">{
                node = node.ParentNode()
                if node != nil </span><span class="cov8" title="1">{
                        result := tw.acceptNode(node)
                        if result == FILTER_ACCEPT </span><span class="cov8" title="1">{
                                tw.currentNode = node
                                return node
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (tw *treeWalker) FirstChild() Node <span class="cov8" title="1">{
        return tw.traverseChildren(true)
}</span>

func (tw *treeWalker) LastChild() Node <span class="cov8" title="1">{
        return tw.traverseChildren(false)
}</span>

func (tw *treeWalker) traverseChildren(first bool) Node <span class="cov8" title="1">{
        node := tw.currentNode
        var child Node
        if first </span><span class="cov8" title="1">{
                child = node.FirstChild()
        }</span> else<span class="cov8" title="1"> {
                child = node.LastChild()
        }</span>

        <span class="cov8" title="1">for child != nil </span><span class="cov8" title="1">{
                result := tw.acceptNode(child)
                if result == FILTER_ACCEPT </span><span class="cov8" title="1">{
                        tw.currentNode = child
                        return child
                }</span>
                <span class="cov0" title="0">if result == FILTER_SKIP </span><span class="cov0" title="0">{
                        var grandchild Node
                        if first </span><span class="cov0" title="0">{
                                grandchild = tw.traverseChildrenHelper(child, true)
                        }</span> else<span class="cov0" title="0"> {
                                grandchild = tw.traverseChildrenHelper(child, false)
                        }</span>
                        <span class="cov0" title="0">if grandchild != nil </span><span class="cov0" title="0">{
                                return grandchild
                        }</span>
                }
                <span class="cov0" title="0">if first </span><span class="cov0" title="0">{
                        child = child.NextSibling()
                }</span> else<span class="cov0" title="0"> {
                        child = child.PreviousSibling()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (tw *treeWalker) traverseChildrenHelper(node Node, first bool) Node <span class="cov0" title="0">{
        var child Node
        if first </span><span class="cov0" title="0">{
                child = node.FirstChild()
        }</span> else<span class="cov0" title="0"> {
                child = node.LastChild()
        }</span>

        <span class="cov0" title="0">for child != nil </span><span class="cov0" title="0">{
                result := tw.acceptNode(child)
                if result == FILTER_ACCEPT </span><span class="cov0" title="0">{
                        tw.currentNode = child
                        return child
                }</span>
                <span class="cov0" title="0">if result == FILTER_SKIP </span><span class="cov0" title="0">{
                        var grandchild Node
                        if first </span><span class="cov0" title="0">{
                                grandchild = tw.traverseChildrenHelper(child, true)
                        }</span> else<span class="cov0" title="0"> {
                                grandchild = tw.traverseChildrenHelper(child, false)
                        }</span>
                        <span class="cov0" title="0">if grandchild != nil </span><span class="cov0" title="0">{
                                return grandchild
                        }</span>
                }
                <span class="cov0" title="0">if first </span><span class="cov0" title="0">{
                        child = child.NextSibling()
                }</span> else<span class="cov0" title="0"> {
                        child = child.PreviousSibling()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (tw *treeWalker) NextSibling() Node <span class="cov8" title="1">{
        return tw.traverseSiblings(true)
}</span>

func (tw *treeWalker) PreviousSibling() Node <span class="cov8" title="1">{
        return tw.traverseSiblings(false)
}</span>

func (tw *treeWalker) traverseSiblings(next bool) Node <span class="cov8" title="1">{
        node := tw.currentNode
        if node == tw.root </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var sibling Node
                if next </span><span class="cov8" title="1">{
                        sibling = node.NextSibling()
                }</span> else<span class="cov8" title="1"> {
                        sibling = node.PreviousSibling()
                }</span>

                <span class="cov8" title="1">for sibling != nil </span><span class="cov8" title="1">{
                        result := tw.acceptNode(sibling)
                        if result == FILTER_ACCEPT </span><span class="cov8" title="1">{
                                tw.currentNode = sibling
                                return sibling
                        }</span>
                        <span class="cov0" title="0">if result == FILTER_SKIP </span><span class="cov0" title="0">{
                                child := tw.traverseSiblingsHelper(sibling, next)
                                if child != nil </span><span class="cov0" title="0">{
                                        return child
                                }</span>
                        }
                        <span class="cov0" title="0">if next </span><span class="cov0" title="0">{
                                sibling = sibling.NextSibling()
                        }</span> else<span class="cov0" title="0"> {
                                sibling = sibling.PreviousSibling()
                        }</span>
                }

                <span class="cov0" title="0">node = node.ParentNode()
                if node == nil || node == tw.root </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if tw.acceptNode(node) == FILTER_ACCEPT </span><span class="cov0" title="0">{
                        continue</span>
                }
        }
}

func (tw *treeWalker) traverseSiblingsHelper(node Node, next bool) Node <span class="cov0" title="0">{
        var child Node
        if next </span><span class="cov0" title="0">{
                child = node.FirstChild()
        }</span> else<span class="cov0" title="0"> {
                child = node.LastChild()
        }</span>

        <span class="cov0" title="0">for child != nil </span><span class="cov0" title="0">{
                result := tw.acceptNode(child)
                if result == FILTER_ACCEPT </span><span class="cov0" title="0">{
                        tw.currentNode = child
                        return child
                }</span>
                <span class="cov0" title="0">if result == FILTER_SKIP </span><span class="cov0" title="0">{
                        grandchild := tw.traverseSiblingsHelper(child, next)
                        if grandchild != nil </span><span class="cov0" title="0">{
                                return grandchild
                        }</span>
                }
                <span class="cov0" title="0">if next </span><span class="cov0" title="0">{
                        child = child.NextSibling()
                }</span> else<span class="cov0" title="0"> {
                        child = child.PreviousSibling()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (tw *treeWalker) PreviousNode() Node <span class="cov0" title="0">{
        node := tw.currentNode
        for node != tw.root </span><span class="cov0" title="0">{
                var sibling Node = node.PreviousSibling()
                for sibling != nil </span><span class="cov0" title="0">{
                        result := tw.acceptNode(sibling)
                        node = sibling
                        for result != FILTER_REJECT &amp;&amp; node.LastChild() != nil </span><span class="cov0" title="0">{
                                node = node.LastChild()
                                result = tw.acceptNode(node)
                        }</span>
                        <span class="cov0" title="0">if result == FILTER_ACCEPT </span><span class="cov0" title="0">{
                                tw.currentNode = node
                                return node
                        }</span>
                        <span class="cov0" title="0">sibling = sibling.PreviousSibling()</span>
                }

                <span class="cov0" title="0">if node == tw.root || node.ParentNode() == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">node = node.ParentNode()

                if tw.acceptNode(node) == FILTER_ACCEPT </span><span class="cov0" title="0">{
                        tw.currentNode = node
                        return node
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (tw *treeWalker) NextNode() Node <span class="cov8" title="1">{
        node := tw.currentNode
        result := FILTER_ACCEPT

        for </span><span class="cov8" title="1">{
                for result != FILTER_REJECT &amp;&amp; node.FirstChild() != nil </span><span class="cov8" title="1">{
                        node = node.FirstChild()
                        result = tw.acceptNode(node)
                        if result == FILTER_ACCEPT </span><span class="cov8" title="1">{
                                tw.currentNode = node
                                return node
                        }</span>
                }

                <span class="cov8" title="1">var sibling Node
                temp := node
                for temp != nil &amp;&amp; temp != tw.root </span><span class="cov8" title="1">{
                        sibling = temp.NextSibling()
                        if sibling != nil </span><span class="cov8" title="1">{
                                node = sibling
                                break</span>
                        }
                        <span class="cov8" title="1">temp = temp.ParentNode()</span>
                }

                <span class="cov8" title="1">if sibling == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">result = tw.acceptNode(node)
                if result == FILTER_ACCEPT </span><span class="cov8" title="1">{
                        tw.currentNode = node
                        return node
                }</span>
        }
}

func (d *document) CreateTreeWalker(root Node, whatToShow uint32, filter NodeFilter) (TreeWalker, error) <span class="cov8" title="1">{
        // Acquire read lock on the document
        d.mu.RLock()
        defer d.mu.RUnlock()

        // The root must be a Node within the document.
        if root == nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotSupportedError", "Root cannot be null")
        }</span>

        <span class="cov8" title="1">tw := &amp;treeWalker{
                root:        root,
                whatToShow:  whatToShow,
                filter:      filter,
                currentNode: root,
        }
        return tw, nil</span>
}

// domRange implements the Range interface
type domRange struct {
        startContainer Node
        startOffset    uint32
        endContainer   Node
        endOffset      uint32
        doc            Document
        detached       bool
}

func (r *domRange) StartContainer() Node <span class="cov8" title="1">{
        return r.startContainer
}</span>

func (r *domRange) StartOffset() uint32 <span class="cov8" title="1">{
        return r.startOffset
}</span>

func (r *domRange) EndContainer() Node <span class="cov8" title="1">{
        return r.endContainer
}</span>

func (r *domRange) EndOffset() uint32 <span class="cov8" title="1">{
        return r.endOffset
}</span>

func (r *domRange) Collapsed() bool <span class="cov8" title="1">{
        return r.startContainer == r.endContainer &amp;&amp; r.startOffset == r.endOffset
}</span>

func (r *domRange) CommonAncestorContainer() Node <span class="cov0" title="0">{
        // Find the common ancestor of start and end containers
        if r.startContainer == r.endContainer </span><span class="cov0" title="0">{
                return r.startContainer
        }</span>

        // Build ancestor chain for start container
        <span class="cov0" title="0">startAncestors := []Node{}
        for n := r.startContainer; n != nil; n = n.ParentNode() </span><span class="cov0" title="0">{
                startAncestors = append(startAncestors, n)
        }</span>

        // Find first common ancestor with end container
        <span class="cov0" title="0">for n := r.endContainer; n != nil; n = n.ParentNode() </span><span class="cov0" title="0">{
                for _, ancestor := range startAncestors </span><span class="cov0" title="0">{
                        if n == ancestor </span><span class="cov0" title="0">{
                                return n
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *domRange) SetStart(node Node, offset uint32) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        // Validate offset
        <span class="cov8" title="1">if err := r.validateOffset(node, offset); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r.startContainer = node
        r.startOffset = offset

        // Ensure start is not after end
        if r.comparePositions(r.startContainer, r.startOffset, r.endContainer, r.endOffset) &gt; 0 </span><span class="cov8" title="1">{
                r.endContainer = node
                r.endOffset = offset
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *domRange) SetEnd(node Node, offset uint32) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        // Validate offset
        <span class="cov8" title="1">if err := r.validateOffset(node, offset); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r.endContainer = node
        r.endOffset = offset

        // Ensure end is not before start
        if r.comparePositions(r.startContainer, r.startOffset, r.endContainer, r.endOffset) &gt; 0 </span><span class="cov0" title="0">{
                r.startContainer = node
                r.startOffset = offset
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *domRange) SetStartBefore(node Node) error <span class="cov0" title="0">{
        if node == nil || node.ParentNode() == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node must have a parent")
        }</span>

        <span class="cov0" title="0">offset := r.getNodeIndex(node)
        return r.SetStart(node.ParentNode(), offset)</span>
}

func (r *domRange) SetStartAfter(node Node) error <span class="cov0" title="0">{
        if node == nil || node.ParentNode() == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node must have a parent")
        }</span>

        <span class="cov0" title="0">offset := r.getNodeIndex(node) + 1
        return r.SetStart(node.ParentNode(), offset)</span>
}

func (r *domRange) SetEndBefore(node Node) error <span class="cov0" title="0">{
        if node == nil || node.ParentNode() == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node must have a parent")
        }</span>

        <span class="cov0" title="0">offset := r.getNodeIndex(node)
        return r.SetEnd(node.ParentNode(), offset)</span>
}

func (r *domRange) SetEndAfter(node Node) error <span class="cov0" title="0">{
        if node == nil || node.ParentNode() == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node must have a parent")
        }</span>

        <span class="cov0" title="0">offset := r.getNodeIndex(node) + 1
        return r.SetEnd(node.ParentNode(), offset)</span>
}

func (r *domRange) Collapse(toStart bool) <span class="cov8" title="1">{
        if toStart </span><span class="cov8" title="1">{
                r.endContainer = r.startContainer
                r.endOffset = r.startOffset
        }</span> else<span class="cov0" title="0"> {
                r.startContainer = r.endContainer
                r.startOffset = r.endOffset
        }</span>
}

func (r *domRange) SelectNode(node Node) error <span class="cov8" title="1">{
        if node == nil || node.ParentNode() == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node must have a parent")
        }</span>

        <span class="cov8" title="1">parent := node.ParentNode()
        offset := r.getNodeIndex(node)

        r.startContainer = parent
        r.startOffset = offset
        r.endContainer = parent
        r.endOffset = offset + 1

        return nil</span>
}

func (r *domRange) SelectNodeContents(node Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        <span class="cov8" title="1">r.startContainer = node
        r.startOffset = 0
        r.endContainer = node
        r.endOffset = r.getNodeLength(node)

        return nil</span>
}

func (r *domRange) CompareBoundaryPoints(how uint16, sourceRange Range) (int16, error) <span class="cov0" title="0">{
        if sourceRange == nil </span><span class="cov0" title="0">{
                return 0, NewDOMException("InvalidStateError", "sourceRange cannot be null")
        }</span>

        <span class="cov0" title="0">var thisNode, otherNode Node
        var thisOffset, otherOffset uint32

        switch how </span>{
        case START_TO_START:<span class="cov0" title="0">
                thisNode = r.startContainer
                thisOffset = r.startOffset
                otherNode = sourceRange.StartContainer()
                otherOffset = sourceRange.StartOffset()</span>
        case START_TO_END:<span class="cov0" title="0">
                thisNode = r.endContainer
                thisOffset = r.endOffset
                otherNode = sourceRange.StartContainer()
                otherOffset = sourceRange.StartOffset()</span>
        case END_TO_END:<span class="cov0" title="0">
                thisNode = r.endContainer
                thisOffset = r.endOffset
                otherNode = sourceRange.EndContainer()
                otherOffset = sourceRange.EndOffset()</span>
        case END_TO_START:<span class="cov0" title="0">
                thisNode = r.startContainer
                thisOffset = r.startOffset
                otherNode = sourceRange.EndContainer()
                otherOffset = sourceRange.EndOffset()</span>
        default:<span class="cov0" title="0">
                return 0, NewDOMException("NotSupportedError", "Invalid comparison type")</span>
        }

        <span class="cov0" title="0">return int16(r.comparePositions(thisNode, thisOffset, otherNode, otherOffset)), nil</span>
}

func (r *domRange) DeleteContents() error <span class="cov0" title="0">{
        if r.Collapsed() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This is a simplified implementation
        // A full implementation would handle partial text node deletion
        // and maintain proper DOM structure

        <span class="cov0" title="0">return nil</span>
}

func (r *domRange) ExtractContents() (DocumentFragment, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // A full implementation would extract and return the contents
        frag := r.doc.CreateDocumentFragment()
        return frag, nil
}</span>

func (r *domRange) CloneContents() (DocumentFragment, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // A full implementation would clone and return the contents
        frag := r.doc.CreateDocumentFragment()
        return frag, nil
}</span>

func (r *domRange) InsertNode(node Node) error <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        // This is a simplified implementation
        // A full implementation would properly insert the node at the start position

        <span class="cov0" title="0">return nil</span>
}

func (r *domRange) SurroundContents(newParent Node) error <span class="cov0" title="0">{
        if newParent == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        // This is a simplified implementation
        // A full implementation would extract contents and insert them into newParent

        <span class="cov0" title="0">return nil</span>
}

func (r *domRange) CloneRange() Range <span class="cov8" title="1">{
        return &amp;domRange{
                startContainer: r.startContainer,
                startOffset:    r.startOffset,
                endContainer:   r.endContainer,
                endOffset:      r.endOffset,
                doc:            r.doc,
        }
}</span>

func (r *domRange) Detach() <span class="cov8" title="1">{
        // Mark the range as detached
        r.detached = true
}</span>

func (r *domRange) IsPointInRange(node Node, offset uint32) (bool, error) <span class="cov8" title="1">{
        if r.detached </span><span class="cov8" title="1">{
                return false, NewDOMException("InvalidStateError", "Range is detached")
        }</span>
        
        <span class="cov8" title="1">if node == nil </span><span class="cov0" title="0">{
                return false, NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        <span class="cov8" title="1">if err := r.validateOffset(node, offset); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">cmp := r.comparePositions(node, offset, r.startContainer, r.startOffset)
        if cmp &lt; 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">cmp = r.comparePositions(node, offset, r.endContainer, r.endOffset)
        if cmp &gt; 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func (r *domRange) ComparePoint(node Node, offset uint32) (int16, error) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return 0, NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        <span class="cov8" title="1">if err := r.validateOffset(node, offset); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if r.comparePositions(node, offset, r.startContainer, r.startOffset) &lt; 0 </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov8" title="1">if r.comparePositions(node, offset, r.endContainer, r.endOffset) &gt; 0 </span><span class="cov0" title="0">{
                return 1, nil
        }</span>

        <span class="cov8" title="1">return 0, nil</span>
}

func (r *domRange) IntersectsNode(node Node) bool <span class="cov8" title="1">{
        if node == nil || node.ParentNode() == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">parent := node.ParentNode()
        offset := r.getNodeIndex(node)

        cmp := r.comparePositions(parent, offset, r.endContainer, r.endOffset)
        if cmp &gt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">cmp = r.comparePositions(parent, offset+1, r.startContainer, r.startOffset)
        return cmp &gt;= 0</span>
}

func (r *domRange) ToString() string <span class="cov0" title="0">{
        // This is a simplified implementation
        // A full implementation would extract text content from the range
        return ""
}</span>

// Helper methods
func (r *domRange) validateOffset(node Node, offset uint32) error <span class="cov8" title="1">{
        length := r.getNodeLength(node)
        if offset &gt; length </span><span class="cov0" title="0">{
                return NewDOMException("IndexSizeError", "Offset out of bounds")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *domRange) getNodeLength(node Node) uint32 <span class="cov8" title="1">{
        switch node.NodeType() </span>{
        case TEXT_NODE, COMMENT_NODE, PROCESSING_INSTRUCTION_NODE:<span class="cov8" title="1">
                if cd, ok := node.(CharacterData); ok </span><span class="cov8" title="1">{
                        return uint32(cd.Length())
                }</span>
        default:<span class="cov8" title="1">
                count := uint32(0)
                for child := node.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        count++
                }</span>
                <span class="cov8" title="1">return count</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (r *domRange) getNodeIndex(node Node) uint32 <span class="cov8" title="1">{
        index := uint32(0)
        for sibling := node.ParentNode().FirstChild(); sibling != nil &amp;&amp; sibling != node; sibling = sibling.NextSibling() </span><span class="cov8" title="1">{
                index++
        }</span>
        <span class="cov8" title="1">return index</span>
}

func (r *domRange) comparePositions(node1 Node, offset1 uint32, node2 Node, offset2 uint32) int <span class="cov8" title="1">{
        if node1 == node2 </span><span class="cov8" title="1">{
                if offset1 &lt; offset2 </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if offset1 &gt; offset2 </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        // Handle container relationships according to DOM Range spec
        <span class="cov8" title="1">position := node1.CompareDocumentPosition(node2)
        
        // If node1 contains node2
        if position&amp;DOCUMENT_POSITION_CONTAINS != 0 </span><span class="cov0" title="0">{
                // node1 contains node2, so we need to find which child of node1 contains node2
                // and compare offset1 with the index of that child
                childIndex := uint32(0)
                for child := node1.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                        if child == node2 || child.Contains(node2) </span><span class="cov0" title="0">{
                                // Found the child that contains node2
                                // Special case: if offset1 equals childIndex and child == node2 and offset2 == 0,
                                // then these positions are equivalent (before child vs start of child)
                                if offset1 == childIndex &amp;&amp; child == node2 &amp;&amp; offset2 == 0 </span><span class="cov0" title="0">{
                                        return 0 // equivalent positions
                                }</span>
                                <span class="cov0" title="0">if offset1 &lt;= childIndex </span><span class="cov0" title="0">{
                                        return -1 // position is before this child
                                }</span> else<span class="cov0" title="0"> {
                                        return 1  // position is after this child
                                }</span>
                        }
                        <span class="cov0" title="0">childIndex++</span>
                }
                <span class="cov0" title="0">return 1</span> // shouldn't reach here in a well-formed DOM
        }
        
        // If node2 contains node1
        <span class="cov8" title="1">if position&amp;DOCUMENT_POSITION_CONTAINED_BY != 0 </span><span class="cov8" title="1">{
                // node2 contains node1, so we need to find which child of node2 contains node1
                // and compare offset2 with the index of that child
                childIndex := uint32(0)
                for child := node2.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        if child == node1 || child.Contains(node1) </span><span class="cov8" title="1">{
                                // Found the child that contains node1
                                // Special case: if offset2 equals childIndex and child == node1 and offset1 == 0,
                                // then these positions are equivalent (before child vs start of child)
                                if offset2 == childIndex &amp;&amp; child == node1 &amp;&amp; offset1 == 0 </span><span class="cov8" title="1">{
                                        return 0 // equivalent positions
                                }</span>
                                <span class="cov8" title="1">if offset2 &lt;= childIndex </span><span class="cov8" title="1">{
                                        return 1  // position is after this child
                                }</span> else<span class="cov8" title="1"> {
                                        return -1 // position is before this child
                                }</span>
                        }
                        <span class="cov0" title="0">childIndex++</span>
                }
                <span class="cov0" title="0">return -1</span> // shouldn't reach here in a well-formed DOM
        }
        
        // Neither contains the other - use document order
        <span class="cov0" title="0">if position&amp;DOCUMENT_POSITION_FOLLOWING != 0 </span><span class="cov0" title="0">{
                return -1 // node1 is before node2
        }</span> else<span class="cov0" title="0"> if position&amp;DOCUMENT_POSITION_PRECEDING != 0 </span><span class="cov0" title="0">{
                return 1  // node1 is after node2
        }</span>

        <span class="cov0" title="0">return 0</span>
}

func (d *document) CreateRange() Range <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        r := &amp;domRange{
                startContainer: d,
                startOffset:    0,
                endContainer:   d,
                endOffset:      0,
                doc:            d,
        }
        return r
}</span>

func (d *document) NormalizeDocument() <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        // Normalize the document element if it exists
        if d.documentElement != nil </span><span class="cov8" title="1">{
                d.documentElement.Normalize()
        }</span> else<span class="cov0" title="0"> {
                // If no document element, normalize the document itself
                d.Normalize()
        }</span>
}

func normalizeNode(node Node) <span class="cov0" title="0">{
        // First recursively normalize all element children
        child := node.FirstChild()
        for child != nil </span><span class="cov0" title="0">{
                next := child.NextSibling()
                if child.NodeType() == ELEMENT_NODE </span><span class="cov0" title="0">{
                        normalizeNode(child)
                }</span>
                <span class="cov0" title="0">child = next</span>
        }

        // Now normalize this node's direct children - collect and merge text nodes
        <span class="cov0" title="0">children := []Node{}
        var mergedText strings.Builder
        var hasPendingText bool

        child = node.FirstChild()
        for child != nil </span><span class="cov0" title="0">{
                switch child.NodeType() </span>{
                case TEXT_NODE:<span class="cov0" title="0">
                        if data := string(child.NodeValue()); data != "" </span><span class="cov0" title="0">{
                                mergedText.WriteString(data)
                                hasPendingText = true
                        }</span>
                        // Don't add the original text node to children - we're merging
                default:<span class="cov0" title="0">
                        // Non-text node: flush any pending merged text
                        if hasPendingText </span><span class="cov0" title="0">{
                                textNode := node.OwnerDocument().CreateTextNode(DOMString(mergedText.String()))
                                children = append(children, textNode)
                                mergedText.Reset()
                                hasPendingText = false
                        }</span>
                        <span class="cov0" title="0">children = append(children, child)</span>
                }
                <span class="cov0" title="0">child = child.NextSibling()</span>
        }

        // Flush any remaining text at the end
        <span class="cov0" title="0">if hasPendingText </span><span class="cov0" title="0">{
                textNode := node.OwnerDocument().CreateTextNode(DOMString(mergedText.String()))
                children = append(children, textNode)
        }</span>

        // Clear and rebuild children if we have changes to make
        <span class="cov0" title="0">if n := getInternalNode(node); n != nil </span><span class="cov0" title="0">{
                // Clear all child relationships
                oldChild := n.firstChild
                for oldChild != nil </span><span class="cov0" title="0">{
                        next := oldChild.NextSibling()
                        if oc := getInternalNode(oldChild); oc != nil </span><span class="cov0" title="0">{
                                oc.parentNode = nil
                                oc.previousSibling = nil
                                oc.nextSibling = nil
                        }</span>
                        <span class="cov0" title="0">oldChild = next</span>
                }

                <span class="cov0" title="0">n.firstChild = nil
                n.lastChild = nil

                // Re-append normalized children
                for _, child := range children </span><span class="cov0" title="0">{
                        node.AppendChild(child)
                }</span>

                // Update live NodeList if it exists
                <span class="cov0" title="0">if n.childNodes != nil &amp;&amp; n.childNodes.update != nil </span><span class="cov0" title="0">{
                        n.childNodes.update()
                }</span>
        }
}

func (d *document) RenameNode(node Node, namespaceURI, qualifiedName DOMString) (Node, error) <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if node == nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("InvalidNodeTypeError", "Node cannot be null")
        }</span>

        // Only element and attribute nodes can be renamed
        <span class="cov8" title="1">switch node.NodeType() </span>{
        case ELEMENT_NODE:<span class="cov8" title="1">
                if elem, ok := node.(*element); ok </span><span class="cov8" title="1">{
                        // Validate the qualified name
                        if qualifiedName == "" </span><span class="cov0" title="0">{
                                return nil, NewDOMException("InvalidCharacterError", "Qualified name cannot be empty")
                        }</span>

                        // Update the element's name and namespace directly
                        <span class="cov8" title="1">elem.nodeName = qualifiedName
                        elem.namespaceURI = namespaceURI
                        elem.localName = qualifiedName // Should be parsed from qualifiedName

                        return elem, nil</span>
                }

        case ATTRIBUTE_NODE:<span class="cov0" title="0">
                if attr, ok := node.(*attr); ok </span><span class="cov0" title="0">{
                        // Validate the qualified name
                        if qualifiedName == "" </span><span class="cov0" title="0">{
                                return nil, NewDOMException("InvalidCharacterError", "Qualified name cannot be empty")
                        }</span>

                        // Update the attribute's name and namespace
                        <span class="cov0" title="0">attr.nodeName = qualifiedName
                        attr.namespaceURI = namespaceURI
                        attr.localName = qualifiedName // Should be parsed from qualifiedName

                        return attr, nil</span>
                }

        default:<span class="cov0" title="0">
                return nil, NewDOMException("NotSupportedError", "Only element and attribute nodes can be renamed")</span>
        }

        <span class="cov0" title="0">return nil, NewDOMException("InvalidNodeTypeError", "Invalid node type")</span>
}

// Document property methods
func (d *document) URL() DOMString <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        return d.url
}</span>

func (d *document) DocumentURI() DOMString <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        return d.documentURI
}</span>

func (d *document) CharacterSet() DOMString <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        if d.characterSet == "" </span><span class="cov8" title="1">{
                return "UTF-8" // Default to UTF-8
        }</span>
        <span class="cov0" title="0">return d.characterSet</span>
}

func (d *document) Charset() DOMString <span class="cov8" title="1">{
        // Alias for CharacterSet
        return d.CharacterSet()
}</span>

func (d *document) InputEncoding() DOMString <span class="cov8" title="1">{
        // Alias for CharacterSet
        return d.CharacterSet()
}</span>

func (d *document) ContentType() DOMString <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        if d.contentType == "" </span><span class="cov8" title="1">{
                return "application/xml" // Default for DOM documents
        }</span>
        <span class="cov0" title="0">return d.contentType</span>
}

// XPath methods implementation

// CreateExpression compiles an XPath expression for reuse
func (d *document) CreateExpression(expression string, resolver XPathNSResolver) (XPathExpression, error) <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        
        if expression == "" </span><span class="cov0" title="0">{
                return nil, NewXPathException("INVALID_EXPRESSION_ERR", "Expression cannot be empty")
        }</span>

        // Parse the XPath expression into AST
        <span class="cov0" title="0">parser := NewXPathParser()
        ast, err := parser.Parse(expression)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create compiled expression
        <span class="cov0" title="0">return &amp;xpathExpression{
                expression: expression,
                resolver:   resolver,
                ast:        ast,
                document:   d,
        }, nil</span>
}

// CreateNSResolver creates a namespace resolver from a node
func (d *document) CreateNSResolver(nodeResolver Node) Node <span class="cov0" title="0">{
        // Return the node as-is - it already implements LookupNamespaceURI
        // which is what we need for XPath namespace resolution
        return nodeResolver
}</span>

// Evaluate evaluates an XPath expression on a context node
func (d *document) Evaluate(expression string, contextNode Node, resolver XPathNSResolver, 
        resultType uint16, result XPathResult) (XPathResult, error) <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        
        if expression == "" </span><span class="cov0" title="0">{
                return nil, NewXPathException("INVALID_EXPRESSION_ERR", "Expression cannot be empty")
        }</span>

        <span class="cov0" title="0">if contextNode == nil </span><span class="cov0" title="0">{
                // Use document as default context node
                contextNode = d
        }</span>

        // Validate that context node belongs to this document
        <span class="cov0" title="0">if contextNode.OwnerDocument() != d &amp;&amp; contextNode.NodeType() != DOCUMENT_NODE </span><span class="cov0" title="0">{
                return nil, NewXPathException("WRONG_DOCUMENT_ERR", "Context node must belong to this document")
        }</span>

        // Create and compile expression
        <span class="cov0" title="0">expr, err := d.CreateExpression(expression, resolver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Evaluate expression
        <span class="cov0" title="0">result, err = expr.Evaluate(contextNode, resultType, result)
        return result, err</span>
}

func (d *document) removeIdMapping(idValue DOMString) <span class="cov8" title="1">{
        if d.idMap != nil &amp;&amp; idValue != "" </span><span class="cov8" title="1">{
                delete(d.idMap, idValue)
        }</span>
}

func (d *document) updateIdMappingForElement(element Element, attributeName DOMString, oldValue, newValue DOMString) <span class="cov8" title="1">{
        if attributeName != "id" </span><span class="cov8" title="1">{
                return
        }</span>

        // Remove old mapping if it exists
        <span class="cov8" title="1">if oldValue != "" </span><span class="cov8" title="1">{
                d.removeIdMapping(oldValue)
        }</span>

        // Add new mapping if new value is not empty
        <span class="cov8" title="1">if newValue != "" </span><span class="cov8" title="1">{
                if d.idMap == nil </span><span class="cov8" title="1">{
                        d.idMap = make(map[DOMString]Element)
                }</span>
                <span class="cov8" title="1">d.idMap[newValue] = element</span>
        }
}

// notifyMutation is called whenever the DOM tree is mutated. It iterates
// over all active live NodeLists and calls their update function to keep
// them in sync with the DOM.
func (d *document) notifyMutation() <span class="cov8" title="1">{
        for _, nl := range d.activeNodeLists </span><span class="cov8" title="1">{
                if nl.update != nil </span><span class="cov8" title="1">{
                        nl.update()
                }</span>
        }
}

// ===========================================================================
// Element Implementation
// ===========================================================================

// element represents an element node
type element struct {
        node
}

func (e *element) InsertBefore(newChild Node, refChild Node) (Node, error) <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }

        <span class="cov8" title="1">if newChild == nil </span><span class="cov8" title="1">{
                return nil, NewDOMException("HierarchyRequestError", "Invalid node")
        }</span>

        // Handle self-insertion: inserting node before itself should be a no-op
        <span class="cov8" title="1">if newChild == refChild </span><span class="cov8" title="1">{
                return newChild, nil
        }</span>

        // Check document ownership
        <span class="cov8" title="1">if newChild.OwnerDocument() != e.ownerDocument &amp;&amp; e.ownerDocument != nil </span><span class="cov8" title="1">{
                return nil, NewDOMException("WrongDocumentError", "")
        }</span>

        // HIERARCHY_REQUEST_ERR check - prevent cycles
        <span class="cov8" title="1">for ancestor := Node(e); ancestor != nil; ancestor = ancestor.ParentNode() </span><span class="cov8" title="1">{
                if ancestor == newChild </span><span class="cov8" title="1">{
                        return nil, NewDOMException("HierarchyRequestError", "Cannot insert a node as a descendant of itself")
                }</span>
        }

        // Handle DocumentFragment - insert its children instead of the fragment itself
        <span class="cov8" title="1">if newChild.NodeType() == DOCUMENT_FRAGMENT_NODE </span><span class="cov8" title="1">{
                // Collect all children of the fragment first
                var children []Node
                for child := newChild.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        children = append(children, child)
                }</span>

                // Insert each child using internal method to avoid infinite recursion
                <span class="cov8" title="1">for _, child := range children </span><span class="cov8" title="1">{
                        // Remove from fragment first
                        if df, ok := newChild.(*documentFragment); ok </span><span class="cov8" title="1">{
                                df.removeChildInternal(child)
                        }</span> else<span class="cov0" title="0"> {
                                newChild.RemoveChild(child)
                        }</span>
                        // Insert into target parent using internal method
                        <span class="cov8" title="1">_, err := e.insertBeforeInternal(child, refChild)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // Return the fragment itself (which is now empty)
                <span class="cov8" title="1">return newChild, nil</span>
        }

        <span class="cov8" title="1">return e.insertBeforeInternal(newChild, refChild)</span>
}

// insertBeforeInternal handles the actual insertion without DocumentFragment expansion for elements
func (e *element) insertBeforeInternal(newChild Node, refChild Node) (Node, error) <span class="cov8" title="1">{

        // Remove from current parent if exists - done internally to avoid deadlock
        if newChild.ParentNode() != nil </span><span class="cov8" title="1">{
                oldParent := newChild.ParentNode()
                oc := getInternalNode(newChild)

                // Update sibling links
                if oc.previousSibling != nil </span><span class="cov0" title="0">{
                        if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                                prevNode.nextSibling = oc.nextSibling
                        }</span>
                }
                <span class="cov8" title="1">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                        if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                                nextNode.previousSibling = oc.previousSibling
                        }</span>
                }

                // Update parent's first/last child pointers
                <span class="cov8" title="1">if op := getInternalNode(oldParent); op != nil </span><span class="cov8" title="1">{
                        if op.firstChild == newChild </span><span class="cov8" title="1">{
                                op.firstChild = oc.nextSibling
                        }</span>
                        <span class="cov8" title="1">if op.lastChild == newChild </span><span class="cov8" title="1">{
                                op.lastChild = oc.previousSibling
                        }</span>
                        // Update old parent's live NodeList if it exists
                        <span class="cov8" title="1">if op.childNodes != nil &amp;&amp; op.childNodes.update != nil </span><span class="cov0" title="0">{
                                op.childNodes.update()
                        }</span>
                }

                // Clear the removed node's parent/sibling references
                <span class="cov8" title="1">oc.parentNode = nil
                oc.previousSibling = nil
                oc.nextSibling = nil</span>
        }

        // Validate refChild
        <span class="cov8" title="1">if refChild != nil &amp;&amp; refChild.ParentNode() != Node(e) </span><span class="cov8" title="1">{
                return nil, NewDOMException("NotFoundError", "refChild not found")
        }</span>

        // Get internal nodes for manipulation
        <span class="cov8" title="1">nc := getInternalNode(newChild)
        rc := getInternalNode(refChild)

        // Append or insert operation
        if refChild == nil </span><span class="cov8" title="1">{
                nc.parentNode = Node(e) // Store as element interface
                nc.previousSibling = e.lastChild
                nc.nextSibling = nil
                if e.lastChild != nil </span><span class="cov8" title="1">{
                        if lastNode := getInternalNode(e.lastChild); lastNode != nil </span><span class="cov8" title="1">{
                                lastNode.nextSibling = newChild
                        }</span>
                }
                <span class="cov8" title="1">e.lastChild = newChild
                if e.firstChild == nil </span><span class="cov8" title="1">{
                        e.firstChild = newChild
                }</span>
        } else<span class="cov8" title="1"> { // Insert operation
                nc.parentNode = Node(e) // Store as element interface
                nc.nextSibling = refChild
                nc.previousSibling = rc.previousSibling
                if rc.previousSibling != nil </span><span class="cov8" title="1">{
                        if prevNode := getInternalNode(rc.previousSibling); prevNode != nil </span><span class="cov8" title="1">{
                                prevNode.nextSibling = newChild
                        }</span>
                } else<span class="cov8" title="1"> {
                        e.firstChild = newChild
                }</span>
                <span class="cov8" title="1">rc.previousSibling = newChild</span>
        }

        // Update live NodeList if it exists
        <span class="cov8" title="1">if e.childNodes != nil &amp;&amp; e.childNodes.update != nil </span><span class="cov8" title="1">{
                e.childNodes.update()
        }</span>
        <span class="cov8" title="1">if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return newChild, nil</span>
}

func (e *element) AppendChild(newChild Node) (Node, error) <span class="cov8" title="1">{
        return e.InsertBefore(newChild, nil)
}</span>

func (e *element) ReplaceChild(newChild Node, oldChild Node) (Node, error) <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }

        <span class="cov8" title="1">if newChild == nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("HierarchyRequestError", "Invalid node")
        }</span>

        <span class="cov8" title="1">if oldChild.ParentNode() != Node(e) </span><span class="cov8" title="1">{
                return nil, NewDOMException("NotFoundError", "")
        }</span>

        // Handle self-replacement: replacing node with itself should be a no-op
        <span class="cov8" title="1">if newChild == oldChild </span><span class="cov8" title="1">{
                return oldChild, nil
        }</span>

        // Check document ownership
        <span class="cov8" title="1">if newChild.OwnerDocument() != e.ownerDocument &amp;&amp; e.ownerDocument != nil </span><span class="cov8" title="1">{
                return nil, NewDOMException("WrongDocumentError", "")
        }</span>

        // HIERARCHY_REQUEST_ERR check - prevent cycles
        <span class="cov8" title="1">for ancestor := Node(e); ancestor != nil; ancestor = ancestor.ParentNode() </span><span class="cov8" title="1">{
                if ancestor == newChild </span><span class="cov0" title="0">{
                        return nil, NewDOMException("HierarchyRequestError", "Cannot insert a node as a descendant of itself")
                }</span>
        }

        // Handle DocumentFragment - replace with its children
        <span class="cov8" title="1">if newChild.NodeType() == DOCUMENT_FRAGMENT_NODE </span><span class="cov8" title="1">{
                // Collect all children of the fragment first
                var children []Node
                for child := newChild.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        children = append(children, child)
                }</span>

                <span class="cov8" title="1">if len(children) == 0 </span><span class="cov0" title="0">{
                        // Empty fragment, just remove the old child
                        return e.RemoveChild(oldChild)
                }</span>

                // Replace with first child, then insert remaining children after it
                <span class="cov8" title="1">firstChild := children[0]
                if df, ok := newChild.(*documentFragment); ok </span><span class="cov8" title="1">{
                        df.removeChildInternal(firstChild)
                }</span> else<span class="cov0" title="0"> {
                        newChild.RemoveChild(firstChild)
                }</span>
                <span class="cov8" title="1">replaced, err := e.replaceChildInternal(firstChild, oldChild)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Insert remaining children after the first one
                <span class="cov8" title="1">refChild := firstChild.NextSibling()
                for _, child := range children[1:] </span><span class="cov8" title="1">{
                        if df, ok := newChild.(*documentFragment); ok </span><span class="cov8" title="1">{
                                df.removeChildInternal(child)
                        }</span> else<span class="cov0" title="0"> {
                                newChild.RemoveChild(child)
                        }</span>
                        <span class="cov8" title="1">_, err := e.insertBeforeInternal(child, refChild)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">return replaced, nil</span>
        }

        <span class="cov8" title="1">return e.replaceChildInternal(newChild, oldChild)</span>
}

// replaceChildInternal handles the actual replacement without DocumentFragment expansion for elements
func (e *element) replaceChildInternal(newChild Node, oldChild Node) (Node, error) <span class="cov8" title="1">{

        // Remove from current parent if exists - done internally to avoid deadlock
        if newChild.ParentNode() != nil </span><span class="cov0" title="0">{
                oldParent := newChild.ParentNode()
                oc := getInternalNode(newChild)

                // Update sibling links
                if oc.previousSibling != nil </span><span class="cov0" title="0">{
                        if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                                prevNode.nextSibling = oc.nextSibling
                        }</span>
                }
                <span class="cov0" title="0">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                        if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                                nextNode.previousSibling = oc.previousSibling
                        }</span>
                }

                // Update parent's first/last child pointers
                <span class="cov0" title="0">if op := getInternalNode(oldParent); op != nil </span><span class="cov0" title="0">{
                        if op.firstChild == newChild </span><span class="cov0" title="0">{
                                op.firstChild = oc.nextSibling
                        }</span>
                        <span class="cov0" title="0">if op.lastChild == newChild </span><span class="cov0" title="0">{
                                op.lastChild = oc.previousSibling
                        }</span>
                        // Update old parent's live NodeList if it exists
                        <span class="cov0" title="0">if op.childNodes != nil &amp;&amp; op.childNodes.update != nil </span><span class="cov0" title="0">{
                                op.childNodes.update()
                        }</span>
                }

                // Clear the removed node's parent/sibling references
                <span class="cov0" title="0">oc.parentNode = nil
                oc.previousSibling = nil
                oc.nextSibling = nil</span>
        }

        <span class="cov8" title="1">nc := getInternalNode(newChild)
        oc := getInternalNode(oldChild)

        nc.nextSibling = oc.nextSibling
        nc.previousSibling = oc.previousSibling
        nc.parentNode = Node(e)

        if oc.previousSibling != nil </span><span class="cov8" title="1">{
                if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov8" title="1">{
                        prevNode.nextSibling = newChild
                }</span>
        } else<span class="cov8" title="1"> {
                e.firstChild = newChild
        }</span>

        <span class="cov8" title="1">if oc.nextSibling != nil </span><span class="cov8" title="1">{
                if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov8" title="1">{
                        nextNode.previousSibling = newChild
                }</span>
        } else<span class="cov8" title="1"> {
                e.lastChild = newChild
        }</span>

        <span class="cov8" title="1">oc.parentNode = nil
        oc.nextSibling = nil
        oc.previousSibling = nil

        // Update live NodeList if it exists
        if e.childNodes != nil &amp;&amp; e.childNodes.update != nil </span><span class="cov0" title="0">{
                e.childNodes.update()
        }</span>
        <span class="cov8" title="1">return oldChild, nil</span>
}

func (e *element) RemoveChild(oldChild Node) (Node, error) <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        // Check parent - need to compare interface values properly
        <span class="cov8" title="1">parent := oldChild.ParentNode()
        if parent == nil || parent != Node(e) </span><span class="cov8" title="1">{
                return nil, NewDOMException("NotFoundError", "")
        }</span>

        <span class="cov8" title="1">oc := getInternalNode(oldChild)

        if oc.previousSibling != nil </span><span class="cov8" title="1">{
                if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov8" title="1">{
                        prevNode.nextSibling = oc.nextSibling
                }</span>
        } else<span class="cov8" title="1"> {
                e.firstChild = oc.nextSibling
        }</span>

        <span class="cov8" title="1">if oc.nextSibling != nil </span><span class="cov8" title="1">{
                if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov8" title="1">{
                        nextNode.previousSibling = oc.previousSibling
                }</span>
        } else<span class="cov8" title="1"> {
                e.lastChild = oc.previousSibling
        }</span>

        <span class="cov8" title="1">oc.parentNode = nil
        oc.nextSibling = nil
        oc.previousSibling = nil

        // Update live NodeList if it exists
        if e.childNodes != nil &amp;&amp; e.childNodes.update != nil </span><span class="cov8" title="1">{
                e.childNodes.update()
        }</span>
        <span class="cov8" title="1">if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return oldChild, nil</span>
}

func (e *element) CloneNode(deep bool) Node <span class="cov8" title="1">{
        clone := &amp;element{
                node: node{
                        nodeType:      e.nodeType,
                        nodeName:      e.nodeName,
                        nodeValue:     e.nodeValue,
                        ownerDocument: e.ownerDocument,
                        namespaceURI:  e.namespaceURI,
                        prefix:        e.prefix,
                        localName:     e.localName,
                },
        }

        if e.attributes != nil </span><span class="cov8" title="1">{
                clone.attributes = NewNamedNodeMap()
                for _, key := range e.attributes.order </span><span class="cov8" title="1">{
                        attr := e.attributes.items[key]
                        clonedAttr := attr.CloneNode(true)
                        clone.attributes.SetNamedItem(clonedAttr)
                }</span>
        }

        <span class="cov8" title="1">if deep </span><span class="cov8" title="1">{
                for child := e.firstChild; child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        clone.AppendChild(child.CloneNode(true))
                }</span>
        }
        <span class="cov8" title="1">return clone</span>
}

// removeChildInternal removes a child without acquiring document lock
// This is used internally to avoid deadlocks when the lock is already held
func (e *element) removeChildInternal(oldChild Node) error <span class="cov0" title="0">{
        // Check parent - need to compare interface values properly
        parent := oldChild.ParentNode()
        if parent == nil || parent != Node(e) </span><span class="cov0" title="0">{
                return NewDOMException("NotFoundError", "")
        }</span>

        <span class="cov0" title="0">oc := getInternalNode(oldChild)

        if oc.previousSibling != nil </span><span class="cov0" title="0">{
                if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                        prevNode.nextSibling = oc.nextSibling
                }</span>
        } else<span class="cov0" title="0"> {
                e.firstChild = oc.nextSibling
        }</span>

        <span class="cov0" title="0">if oc.nextSibling != nil </span><span class="cov0" title="0">{
                if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov0" title="0">{
                        nextNode.previousSibling = oc.previousSibling
                }</span>
        } else<span class="cov0" title="0"> {
                e.lastChild = oc.previousSibling
        }</span>

        <span class="cov0" title="0">oc.parentNode = nil
        oc.nextSibling = nil
        oc.previousSibling = nil

        // Update live NodeList if it exists
        if e.childNodes != nil &amp;&amp; e.childNodes.update != nil </span><span class="cov0" title="0">{
                e.childNodes.update()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (e *element) TagName() DOMString <span class="cov8" title="1">{
        return e.nodeName
}</span>

func (e *element) GetAttribute(name DOMString) DOMString <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">if e.attributes != nil </span><span class="cov8" title="1">{
                if attr := e.attributes.GetNamedItem(name); attr != nil </span><span class="cov8" title="1">{
                        return attr.NodeValue()
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (e *element) SetAttribute(name, value DOMString) error <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">if e.attributes == nil </span><span class="cov0" title="0">{
                e.attributes = NewNamedNodeMap()
        }</span>

        <span class="cov8" title="1">var oldValue DOMString
        if existingAttr := e.attributes.GetNamedItem(name); existingAttr != nil </span><span class="cov8" title="1">{
                oldValue = existingAttr.NodeValue()
                existingAttr.SetNodeValue(value)
        }</span> else<span class="cov8" title="1"> {
                oldValue = ""
                newAttr, err := e.ownerDocument.CreateAttribute(name)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if newAttr == nil </span><span class="cov0" title="0">{
                        return NewDOMException("InvalidCharacterError", "Invalid attribute name")
                }</span>
                <span class="cov8" title="1">a := newAttr.(*attr)
                a.ownerElement = e
                newAttr.SetValue(value)
                e.attributes.SetNamedItem(newAttr)</span>
        }

        // Update ID mapping
        <span class="cov8" title="1">if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.updateIdMappingForElement(e, name, oldValue, value)
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (e *element) RemoveAttribute(name DOMString) error <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }

        <span class="cov8" title="1">var oldValue DOMString
        if e.attributes != nil </span><span class="cov8" title="1">{
                if existingAttr := e.attributes.GetNamedItem(name); existingAttr != nil </span><span class="cov8" title="1">{
                        oldValue = existingAttr.NodeValue()
                }</span>
                <span class="cov8" title="1">e.attributes.RemoveNamedItem(name)</span>
        }

        // Update ID mapping
        <span class="cov8" title="1">if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.updateIdMappingForElement(e, name, oldValue, "")
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (e *element) GetAttributeNode(name DOMString) Attr <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">if e.attributes != nil </span><span class="cov8" title="1">{
                if n := e.attributes.GetNamedItem(name); n != nil </span><span class="cov8" title="1">{
                        return n.(Attr)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *element) SetAttributeNode(newAttr Attr) (Attr, error) <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">a := newAttr.(*attr)
        if a.ownerElement != nil </span><span class="cov8" title="1">{
                return nil, NewDOMException("InUseAttributeError", "Attribute already in use")
        }</span>
        <span class="cov8" title="1">if e.attributes == nil </span><span class="cov0" title="0">{
                e.attributes = NewNamedNodeMap()
        }</span>

        <span class="cov8" title="1">var oldValue DOMString
        oldNode, _ := e.attributes.SetNamedItem(newAttr)
        if oldNode != nil </span><span class="cov8" title="1">{
                oldValue = oldNode.NodeValue()
                // Clear ownerElement of the replaced attribute
                if oldAttr, ok := oldNode.(*attr); ok </span><span class="cov8" title="1">{
                        oldAttr.ownerElement = nil
                }</span>
        }

        <span class="cov8" title="1">a.ownerElement = e

        // Update ID mapping
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.updateIdMappingForElement(e, newAttr.NodeName(), oldValue, newAttr.NodeValue())
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">if oldNode != nil </span><span class="cov8" title="1">{
                return oldNode.(Attr), nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (e *element) RemoveAttributeNode(oldAttr Attr) (Attr, error) <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">if e.attributes == nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "Attribute not found")
        }</span>
        <span class="cov8" title="1">removedNode, err := e.attributes.RemoveNamedItem(oldAttr.Name())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Nullify the ownerElement of the removed attribute
        <span class="cov8" title="1">if removedAttr, ok := removedNode.(*attr); ok </span><span class="cov8" title="1">{
                removedAttr.ownerElement = nil
        }</span>
        
        <span class="cov8" title="1">if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return removedNode.(Attr), nil</span>
}

func (e *element) GetElementsByTagName(name DOMString) NodeList <span class="cov8" title="1">{
        doc, ok := e.ownerDocument.(*document)
        if !ok </span><span class="cov0" title="0">{
                // Should not happen in a well-formed document
                return &amp;nodeList{items: []Node{}}
        }</span>
        <span class="cov8" title="1">if doc != nil </span><span class="cov8" title="1">{
                doc.mu.RLock()
                defer doc.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">nl := &amp;nodeList{
                root: e,
                filter: func(n Node) bool </span><span class="cov8" title="1">{
                        return n.NodeType() == ELEMENT_NODE &amp;&amp; (name == "*" || n.NodeName() == name)
                }</span>,
                live: true,
                doc:  doc,
        }
        <span class="cov8" title="1">nl.update = func() </span><span class="cov8" title="1">{
                nodes := []Node{}
                var helper func(Node)
                helper = func(n Node) </span><span class="cov8" title="1">{
                        if n == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if nl.filter(n) </span><span class="cov8" title="1">{
                                nodes = append(nodes, n)
                        }</span>
                        <span class="cov8" title="1">for child := n.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                                helper(child)
                        }</span>
                }
                // Start with children of root, not root itself (DOM spec: descendants only)
                <span class="cov8" title="1">for child := nl.root.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        helper(child)
                }</span>
                <span class="cov8" title="1">nl.items = nodes</span>
        }
        <span class="cov8" title="1">nl.update() // initial population
        if doc.activeNodeLists == nil </span><span class="cov0" title="0">{
                doc.activeNodeLists = []*nodeList{}
        }</span>
        <span class="cov8" title="1">doc.activeNodeLists = append(doc.activeNodeLists, nl)
        return nl</span>
}

func (e *element) GetAttributeNS(namespaceURI, localName DOMString) DOMString <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">if e.attributes != nil </span><span class="cov8" title="1">{
                if attr := e.attributes.GetNamedItemNS(namespaceURI, localName); attr != nil </span><span class="cov8" title="1">{
                        return attr.NodeValue()
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (e *element) SetAttributeNS(namespaceURI, qualifiedName, value DOMString) error <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">if e.attributes == nil </span><span class="cov0" title="0">{
                e.attributes = NewNamedNodeMap()
        }</span>
        <span class="cov8" title="1">_, localName := parseQualifiedName(qualifiedName)
        var oldValue DOMString
        if existingAttr := e.attributes.GetNamedItemNS(namespaceURI, localName); existingAttr != nil </span><span class="cov8" title="1">{
                oldValue = existingAttr.NodeValue()
                existingAttr.SetNodeValue(value)
        }</span> else<span class="cov8" title="1"> {
                oldValue = ""
                newAttr, _ := e.ownerDocument.CreateAttributeNS(namespaceURI, qualifiedName)
                a := newAttr.(*attr)
                a.ownerElement = e
                newAttr.SetValue(value)
                e.attributes.SetNamedItemNS(newAttr)
        }</span>

        // Update ID mapping
        <span class="cov8" title="1">if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.updateIdMappingForElement(e, localName, oldValue, value)
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (e *element) RemoveAttributeNS(namespaceURI, localName DOMString) error <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">if e.attributes != nil </span><span class="cov8" title="1">{
                e.attributes.RemoveNamedItemNS(namespaceURI, localName)
        }</span>
        <span class="cov8" title="1">if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (e *element) GetAttributeNodeNS(namespaceURI, localName DOMString) Attr <span class="cov0" title="0">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov0" title="0">{
                if d, ok := doc.(*document); ok </span><span class="cov0" title="0">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov0" title="0">if e.attributes != nil </span><span class="cov0" title="0">{
                if n := e.attributes.GetNamedItemNS(namespaceURI, localName); n != nil </span><span class="cov0" title="0">{
                        return n.(Attr)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *element) SetAttributeNodeNS(newAttr Attr) (Attr, error) <span class="cov0" title="0">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov0" title="0">{
                if d, ok := doc.(*document); ok </span><span class="cov0" title="0">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov0" title="0">a := newAttr.(*attr)
        if a.ownerElement != nil </span><span class="cov0" title="0">{
                return nil, NewDOMException("InUseAttributeError", "Attribute already in use")
        }</span>
        <span class="cov0" title="0">if e.attributes == nil </span><span class="cov0" title="0">{
                e.attributes = NewNamedNodeMap()
        }</span>
        <span class="cov0" title="0">oldNode, _ := e.attributes.SetNamedItemNS(newAttr)
        a.ownerElement = e
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov0" title="0">{
                if d, ok := doc.(*document); ok </span><span class="cov0" title="0">{
                        d.notifyMutation()
                }</span>
        }
        <span class="cov0" title="0">if oldNode != nil </span><span class="cov0" title="0">{
                return oldNode.(Attr), nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (e *element) GetElementsByTagNameNS(namespaceURI, localName DOMString) NodeList <span class="cov8" title="1">{
        doc, ok := e.ownerDocument.(*document)
        if !ok </span><span class="cov0" title="0">{
                // Should not happen in a well-formed document
                return &amp;nodeList{items: []Node{}}
        }</span>
        <span class="cov8" title="1">if doc != nil </span><span class="cov8" title="1">{
                doc.mu.RLock()
                defer doc.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">nl := &amp;nodeList{
                root: e,
                filter: func(n Node) bool </span><span class="cov8" title="1">{
                        return n.NodeType() == ELEMENT_NODE &amp;&amp;
                                (namespaceURI == "*" || n.NamespaceURI() == namespaceURI) &amp;&amp;
                                (localName == "*" || n.LocalName() == localName)
                }</span>,
                live: true,
                doc:  doc,
        }
        <span class="cov8" title="1">nl.update = func() </span><span class="cov8" title="1">{
                nodes := []Node{}
                var helper func(Node)
                helper = func(n Node) </span><span class="cov8" title="1">{
                        if n == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if nl.filter(n) </span><span class="cov8" title="1">{
                                nodes = append(nodes, n)
                        }</span>
                        <span class="cov8" title="1">for child := n.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                                helper(child)
                        }</span>
                }
                // Start with children of root, not root itself (DOM spec: descendants only)
                <span class="cov8" title="1">for child := nl.root.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        helper(child)
                }</span>
                <span class="cov8" title="1">nl.items = nodes</span>
        }
        <span class="cov8" title="1">nl.update() // initial population
        if doc.activeNodeLists == nil </span><span class="cov0" title="0">{
                doc.activeNodeLists = []*nodeList{}
        }</span>
        <span class="cov8" title="1">doc.activeNodeLists = append(doc.activeNodeLists, nl)
        return nl</span>
}

// hasAttributeInternal checks if an attribute exists without acquiring locks
// This is used internally when locks are already held to avoid deadlocks
func (e *element) hasAttributeInternal(name DOMString) bool <span class="cov8" title="1">{
        return e.attributes != nil &amp;&amp; e.attributes.GetNamedItem(name) != nil
}</span>

func (e *element) HasAttribute(name DOMString) bool <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">return e.hasAttributeInternal(name)</span>
}

// hasAttributeNSInternal checks if a namespaced attribute exists without acquiring locks
func (e *element) hasAttributeNSInternal(namespaceURI, localName DOMString) bool <span class="cov8" title="1">{
        return e.attributes != nil &amp;&amp; e.attributes.GetNamedItemNS(namespaceURI, localName) != nil
}</span>

func (e *element) HasAttributeNS(namespaceURI, localName DOMString) bool <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">return e.hasAttributeNSInternal(namespaceURI, localName)</span>
}

// Element manipulation methods from Living Standard

func (e *element) ToggleAttribute(name DOMString, force ...bool) bool <span class="cov8" title="1">{
        if doc := e.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }

        // Use internal helper to avoid nested lock acquisition
        <span class="cov8" title="1">hasAttr := e.hasAttributeInternal(name)

        // Determine action based on force parameter
        var shouldAdd bool
        if len(force) &gt; 0 </span><span class="cov8" title="1">{
                shouldAdd = force[0]
        }</span> else<span class="cov8" title="1"> {
                shouldAdd = !hasAttr
        }</span>

        <span class="cov8" title="1">if shouldAdd &amp;&amp; !hasAttr </span><span class="cov8" title="1">{
                // Create attribute internally without additional locking
                if e.attributes == nil </span><span class="cov0" title="0">{
                        e.attributes = NewNamedNodeMap()
                }</span>

                // Create a new attribute
                <span class="cov8" title="1">newAttr, _ := e.ownerDocument.CreateAttribute(name)
                a := newAttr.(*attr)
                a.ownerElement = e
                newAttr.SetValue("")
                e.attributes.SetNamedItem(newAttr)

                // Update ID index if this is an ID attribute
                if doc := e.OwnerDocument(); doc != nil &amp;&amp; name == "id" </span><span class="cov0" title="0">{
                        if d, ok := doc.(*document); ok </span><span class="cov0" title="0">{
                                d.updateIdMappingForElement(e, name, "", "")
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        } else<span class="cov8" title="1"> if !shouldAdd &amp;&amp; hasAttr </span><span class="cov8" title="1">{
                // Remove attribute internally without additional locking
                if e.attributes != nil </span><span class="cov8" title="1">{
                        if attr := e.attributes.GetNamedItem(name); attr != nil </span><span class="cov8" title="1">{
                                // Update ID index if this is an ID attribute
                                if doc := e.OwnerDocument(); doc != nil &amp;&amp; name == "id" </span><span class="cov0" title="0">{
                                        if d, ok := doc.(*document); ok </span><span class="cov0" title="0">{
                                                d.updateIdMappingForElement(e, name, attr.NodeValue(), "")
                                        }</span>
                                }
                                <span class="cov8" title="1">e.attributes.RemoveNamedItem(name)</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">return shouldAdd</span>
}

func (e *element) Remove() <span class="cov8" title="1">{
        if parent := e.ParentNode(); parent != nil </span><span class="cov8" title="1">{
                parent.RemoveChild(e)
        }</span>
}

func (e *element) ReplaceWith(nodes ...Node) error <span class="cov8" title="1">{
        parent := e.ParentNode()
        if parent == nil </span><span class="cov0" title="0">{
                return nil // No parent, nothing to do
        }</span>

        <span class="cov8" title="1">if len(nodes) == 0 </span><span class="cov8" title="1">{
                parent.RemoveChild(e)
                return nil
        }</span>

        // Create a document fragment to hold the nodes
        <span class="cov8" title="1">doc := e.OwnerDocument()
        if doc == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidStateError", "Element has no owner document")
        }</span>

        <span class="cov8" title="1">frag := doc.CreateDocumentFragment()
        for _, node := range nodes </span><span class="cov8" title="1">{
                frag.AppendChild(node)
        }</span>

        // Replace this element with the fragment
        <span class="cov8" title="1">_, err := parent.ReplaceChild(frag, e)
        return err</span>
}

func (e *element) Before(nodes ...Node) error <span class="cov8" title="1">{
        parent := e.ParentNode()
        if parent == nil </span><span class="cov0" title="0">{
                return nil // No parent, nothing to do
        }</span>

        <span class="cov8" title="1">if len(nodes) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Create a document fragment to hold the nodes
        <span class="cov8" title="1">doc := e.OwnerDocument()
        if doc == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidStateError", "Element has no owner document")
        }</span>

        <span class="cov8" title="1">frag := doc.CreateDocumentFragment()
        for _, node := range nodes </span><span class="cov8" title="1">{
                frag.AppendChild(node)
        }</span>

        // Insert the fragment before this element
        <span class="cov8" title="1">_, err := parent.InsertBefore(frag, e)
        return err</span>
}

func (e *element) After(nodes ...Node) error <span class="cov8" title="1">{
        parent := e.ParentNode()
        if parent == nil </span><span class="cov0" title="0">{
                return nil // No parent, nothing to do
        }</span>

        <span class="cov8" title="1">if len(nodes) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Create a document fragment to hold the nodes
        <span class="cov8" title="1">doc := e.OwnerDocument()
        if doc == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidStateError", "Element has no owner document")
        }</span>

        <span class="cov8" title="1">frag := doc.CreateDocumentFragment()
        for _, node := range nodes </span><span class="cov8" title="1">{
                frag.AppendChild(node)
        }</span>

        // Insert the fragment after this element
        <span class="cov8" title="1">nextSibling := e.NextSibling()
        if nextSibling != nil </span><span class="cov8" title="1">{
                _, err := parent.InsertBefore(frag, nextSibling)
                return err
        }</span> else<span class="cov0" title="0"> {
                _, err := parent.AppendChild(frag)
                return err
        }</span>
}

func (e *element) Prepend(nodes ...Node) error <span class="cov8" title="1">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a document fragment to hold the nodes
        <span class="cov8" title="1">doc := e.OwnerDocument()
        if doc == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidStateError", "Element has no owner document")
        }</span>

        <span class="cov8" title="1">frag := doc.CreateDocumentFragment()
        for _, node := range nodes </span><span class="cov8" title="1">{
                frag.AppendChild(node)
        }</span>

        // Insert at the beginning
        <span class="cov8" title="1">firstChild := e.FirstChild()
        if firstChild != nil </span><span class="cov8" title="1">{
                _, err := e.InsertBefore(frag, firstChild)
                return err
        }</span> else<span class="cov0" title="0"> {
                _, err := e.AppendChild(frag)
                return err
        }</span>
}

func (e *element) Append(nodes ...Node) error <span class="cov8" title="1">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a document fragment to hold the nodes
        <span class="cov8" title="1">doc := e.OwnerDocument()
        if doc == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidStateError", "Element has no owner document")
        }</span>

        <span class="cov8" title="1">frag := doc.CreateDocumentFragment()
        for _, node := range nodes </span><span class="cov8" title="1">{
                frag.AppendChild(node)
        }</span>

        // Append to the end
        <span class="cov8" title="1">_, err := e.AppendChild(frag)
        return err</span>
}

// Element DOM properties from Living Standard

func (e *element) Children() ElementList <span class="cov8" title="1">{
        // Return a live collection of child elements only
        doc, ok := e.ownerDocument.(*document)
        if !ok </span><span class="cov0" title="0">{
                // Should not happen in a well-formed document
                return &amp;elementList{items: []Element{}}
        }</span>
        <span class="cov8" title="1">if doc != nil </span><span class="cov8" title="1">{
                doc.mu.RLock()
                defer doc.mu.RUnlock()
        }</span>

        <span class="cov8" title="1">el := &amp;elementList{
                root: e,
                filter: func(n Node) bool </span><span class="cov8" title="1">{
                        // Only include element nodes that are direct children
                        if n.NodeType() != ELEMENT_NODE </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">return n.ParentNode() == e</span>
                },
                converter: func(n Node) (Element, bool) <span class="cov8" title="1">{
                        elem, ok := n.(Element)
                        return elem, ok
                }</span>,
                live: true,
                doc:  doc,
        }

        // Initial population - collect child elements
        <span class="cov8" title="1">child := e.FirstChild()
        for child != nil </span><span class="cov8" title="1">{
                if el.filter != nil &amp;&amp; el.filter(child) </span><span class="cov8" title="1">{
                        if elem, ok := el.converter(child); ok </span><span class="cov8" title="1">{
                                el.items = append(el.items, elem)
                        }</span>
                }
                <span class="cov8" title="1">child = child.NextSibling()</span>
        }

        <span class="cov8" title="1">return el</span>
}

func (e *element) FirstElementChild() Element <span class="cov8" title="1">{
        child := e.FirstChild()
        for child != nil </span><span class="cov8" title="1">{
                if child.NodeType() == ELEMENT_NODE </span><span class="cov8" title="1">{
                        if elem, ok := child.(Element); ok </span><span class="cov8" title="1">{
                                return elem
                        }</span>
                }
                <span class="cov0" title="0">child = child.NextSibling()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *element) LastElementChild() Element <span class="cov8" title="1">{
        child := e.LastChild()
        for child != nil </span><span class="cov8" title="1">{
                if child.NodeType() == ELEMENT_NODE </span><span class="cov8" title="1">{
                        if elem, ok := child.(Element); ok </span><span class="cov8" title="1">{
                                return elem
                        }</span>
                }
                <span class="cov0" title="0">child = child.PreviousSibling()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *element) PreviousElementSibling() Element <span class="cov8" title="1">{
        sibling := e.PreviousSibling()
        for sibling != nil </span><span class="cov8" title="1">{
                if sibling.NodeType() == ELEMENT_NODE </span><span class="cov8" title="1">{
                        if elem, ok := sibling.(Element); ok </span><span class="cov8" title="1">{
                                return elem
                        }</span>
                }
                <span class="cov8" title="1">sibling = sibling.PreviousSibling()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *element) NextElementSibling() Element <span class="cov8" title="1">{
        sibling := e.NextSibling()
        for sibling != nil </span><span class="cov8" title="1">{
                if sibling.NodeType() == ELEMENT_NODE </span><span class="cov8" title="1">{
                        if elem, ok := sibling.(Element); ok </span><span class="cov8" title="1">{
                                return elem
                        }</span>
                }
                <span class="cov8" title="1">sibling = sibling.NextSibling()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *element) ChildElementCount() uint32 <span class="cov8" title="1">{
        count := uint32(0)
        child := e.FirstChild()
        for child != nil </span><span class="cov8" title="1">{
                if child.NodeType() == ELEMENT_NODE </span><span class="cov8" title="1">{
                        count++
                }</span>
                <span class="cov8" title="1">child = child.NextSibling()</span>
        }
        <span class="cov8" title="1">return count</span>
}

// ===========================================================================
// Attribute Implementation
// ===========================================================================

// attr represents an attribute node
type attr struct {
        node
        ownerElement Element
}

func (a *attr) Name() DOMString <span class="cov8" title="1">{
        return a.nodeName
}</span>

func (a *attr) Value() DOMString <span class="cov8" title="1">{
        return a.nodeValue
}</span>

func (a *attr) SetValue(value DOMString) <span class="cov8" title="1">{
        oldValue := a.nodeValue
        a.nodeValue = value
        if a.ownerElement != nil &amp;&amp; a.ownerElement.OwnerDocument() != nil </span><span class="cov8" title="1">{
                if doc, ok := a.ownerElement.OwnerDocument().(*document); ok </span><span class="cov8" title="1">{
                        doc.updateIdMappingForElement(a.ownerElement, a.nodeName, oldValue, value)
                }</span>
        }
}

func (a *attr) OwnerElement() Element <span class="cov8" title="1">{
        if a.ownerElement != nil </span><span class="cov8" title="1">{
                return a.ownerElement
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ===========================================================================
// CharacterData Implementation
// ===========================================================================

// characterData represents character data
type characterData struct {
        node
}

func (cd *characterData) Data() DOMString <span class="cov8" title="1">{
        return cd.nodeValue
}</span>

func (cd *characterData) SetData(data DOMString) error <span class="cov8" title="1">{
        if doc := cd.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">cd.nodeValue = data
        return nil</span>
}

func (cd *characterData) Length() uint <span class="cov8" title="1">{
        return uint(len(cd.nodeValue))
}</span>

func (cd *characterData) SubstringData(offset, count uint) (DOMString, error) <span class="cov8" title="1">{
        if doc := cd.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.RLock()
                        defer d.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">length := cd.Length()
        if offset &gt; length </span><span class="cov8" title="1">{
                return "", NewDOMException("IndexSizeError", "Offset out of bounds")
        }</span>
        <span class="cov8" title="1">end := offset + count
        if end &gt; length </span><span class="cov0" title="0">{
                end = length
        }</span>
        <span class="cov8" title="1">return cd.nodeValue[offset:end], nil</span>
}

func (cd *characterData) AppendData(arg DOMString) error <span class="cov8" title="1">{
        if doc := cd.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">cd.nodeValue = cd.nodeValue + arg
        return nil</span>
}

func (cd *characterData) InsertData(offset uint, arg DOMString) error <span class="cov8" title="1">{
        if doc := cd.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">length := cd.Length()
        if offset &gt; length </span><span class="cov0" title="0">{
                return NewDOMException("IndexSizeError", "Offset out of bounds")
        }</span>
        <span class="cov8" title="1">cd.nodeValue = cd.nodeValue[:offset] + arg + cd.nodeValue[offset:]
        return nil</span>
}

func (cd *characterData) DeleteData(offset, count uint) error <span class="cov8" title="1">{
        if doc := cd.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">length := cd.Length()
        if offset &gt; length </span><span class="cov0" title="0">{
                return NewDOMException("IndexSizeError", "Offset out of bounds")
        }</span>
        <span class="cov8" title="1">end := offset + count
        if end &gt; length </span><span class="cov8" title="1">{
                end = length
        }</span>
        <span class="cov8" title="1">cd.nodeValue = cd.nodeValue[:offset] + cd.nodeValue[end:]
        return nil</span>
}

func (cd *characterData) ReplaceData(offset, count uint, arg DOMString) error <span class="cov8" title="1">{
        if err := cd.DeleteData(offset, count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cd.InsertData(offset, arg)</span>
}

// CharacterData manipulation methods from Living Standard

func (cd *characterData) Before(nodes ...Node) error <span class="cov8" title="1">{
        parent := cd.ParentNode()
        if parent == nil </span><span class="cov0" title="0">{
                return nil // No parent, nothing to do
        }</span>

        <span class="cov8" title="1">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Insert each node directly before this node
        <span class="cov8" title="1">for _, node := range nodes </span><span class="cov8" title="1">{
                _, err := parent.InsertBefore(node, cd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (cd *characterData) After(nodes ...Node) error <span class="cov8" title="1">{
        parent := cd.ParentNode()
        if parent == nil </span><span class="cov0" title="0">{
                return nil // No parent, nothing to do
        }</span>

        <span class="cov8" title="1">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a document fragment to hold the nodes
        <span class="cov8" title="1">doc := cd.OwnerDocument()
        if doc == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidStateError", "CharacterData has no owner document")
        }</span>

        <span class="cov8" title="1">frag := doc.CreateDocumentFragment()
        for _, node := range nodes </span><span class="cov8" title="1">{
                frag.AppendChild(node)
        }</span>

        // Insert the fragment after this node
        <span class="cov8" title="1">nextSibling := cd.NextSibling()
        if nextSibling != nil </span><span class="cov0" title="0">{
                _, err := parent.InsertBefore(frag, nextSibling)
                return err
        }</span> else<span class="cov8" title="1"> {
                _, err := parent.AppendChild(frag)
                return err
        }</span>
}

func (cd *characterData) ReplaceWith(nodes ...Node) error <span class="cov8" title="1">{
        parent := cd.ParentNode()
        if parent == nil </span><span class="cov0" title="0">{
                return nil // No parent, nothing to do
        }</span>

        <span class="cov8" title="1">if len(nodes) == 0 </span><span class="cov0" title="0">{
                parent.RemoveChild(cd)
                return nil
        }</span>

        // Create a document fragment to hold the nodes
        <span class="cov8" title="1">doc := cd.OwnerDocument()
        if doc == nil </span><span class="cov0" title="0">{
                return NewDOMException("InvalidStateError", "CharacterData has no owner document")
        }</span>

        <span class="cov8" title="1">frag := doc.CreateDocumentFragment()
        for _, node := range nodes </span><span class="cov8" title="1">{
                frag.AppendChild(node)
        }</span>

        // Replace this node with the fragment
        <span class="cov8" title="1">_, err := parent.ReplaceChild(frag, cd)
        return err</span>
}

func (cd *characterData) Remove() <span class="cov8" title="1">{
        if parent := cd.ParentNode(); parent != nil </span><span class="cov8" title="1">{
                parent.RemoveChild(cd)
        }</span>
}

// ===========================================================================
// Text Node Implementation
// ===========================================================================

// text represents a text node
type text struct {
        characterData
}

func (t *text) SplitText(offset uint) (Text, error) <span class="cov8" title="1">{
        if doc := t.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">length := t.Length()
        if offset &gt; length </span><span class="cov8" title="1">{
                return nil, NewDOMException("IndexSizeError", "Offset out of bounds")
        }</span>

        <span class="cov8" title="1">newData := t.nodeValue[offset:]
        t.nodeValue = t.nodeValue[:offset]

        newText := t.ownerDocument.CreateTextNode(newData).(*text)

        // Manually insert the new text node after the current one
        if t.parentNode != nil </span><span class="cov8" title="1">{
                newText.parentNode = t.parentNode

                // Update sibling pointers
                newText.previousSibling = t
                newText.nextSibling = t.nextSibling

                if t.nextSibling != nil </span><span class="cov8" title="1">{
                        if ns := getInternalNode(t.nextSibling); ns != nil </span><span class="cov8" title="1">{
                                ns.previousSibling = newText
                        }</span>
                }
                <span class="cov8" title="1">t.nextSibling = newText

                // Update parent's lastChild if needed
                if p := getInternalNode(t.parentNode); p != nil </span><span class="cov8" title="1">{
                        if p.lastChild == t </span><span class="cov8" title="1">{
                                p.lastChild = newText
                        }</span>
                        // Update parent's live NodeList if it exists
                        <span class="cov8" title="1">if p.childNodes != nil &amp;&amp; p.childNodes.update != nil </span><span class="cov0" title="0">{
                                p.childNodes.update()
                        }</span>
                }
        }

        <span class="cov8" title="1">return newText, nil</span>
}

// ===========================================================================
// Other Node Types
// ===========================================================================

// comment represents a comment node
type comment struct {
        characterData
}

// cdataSection represents a CDATA section
type cdataSection struct {
        text
}

// documentType represents a document type node
type documentType struct {
        node
        name           DOMString
        entities       *namedNodeMap
        notations      *namedNodeMap
        publicId       DOMString
        systemId       DOMString
        internalSubset DOMString
}

func (dt *documentType) Name() DOMString <span class="cov8" title="1">{
        return dt.name
}</span>

func (dt *documentType) Entities() NamedNodeMap <span class="cov8" title="1">{
        return dt.entities
}</span>

func (dt *documentType) Notations() NamedNodeMap <span class="cov8" title="1">{
        return dt.notations
}</span>

func (dt *documentType) PublicId() DOMString <span class="cov8" title="1">{
        return dt.publicId
}</span>

func (dt *documentType) SystemId() DOMString <span class="cov8" title="1">{
        return dt.systemId
}</span>

func (dt *documentType) InternalSubset() DOMString <span class="cov0" title="0">{
        return dt.internalSubset
}</span>

// notation represents a notation node
type notation struct {
        node
        publicId DOMString
        systemId DOMString
}

func (n *notation) PublicId() DOMString <span class="cov0" title="0">{
        return n.publicId
}</span>

func (n *notation) SystemId() DOMString <span class="cov0" title="0">{
        return n.systemId
}</span>

// entity represents an entity node
type entity struct {
        node
        publicId     DOMString
        systemId     DOMString
        notationName DOMString
}

func (e *entity) PublicId() DOMString <span class="cov0" title="0">{
        return e.publicId
}</span>

func (e *entity) SystemId() DOMString <span class="cov0" title="0">{
        return e.systemId
}</span>

func (e *entity) NotationName() DOMString <span class="cov0" title="0">{
        return e.notationName
}</span>

// entityReference represents an entity reference node
type entityReference struct {
        node
}

// processingInstruction represents a processing instruction node
type processingInstruction struct {
        node
        target DOMString
        data   DOMString
}

func (pi *processingInstruction) Target() DOMString <span class="cov8" title="1">{
        return pi.target
}</span>

func (pi *processingInstruction) Data() DOMString <span class="cov8" title="1">{
        return pi.data
}</span>

func (pi *processingInstruction) SetData(data DOMString) error <span class="cov8" title="1">{
        if doc := pi.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">pi.data = data
        pi.nodeValue = data
        return nil</span>
}

// documentFragment represents a document fragment node
type documentFragment struct {
        node
}

func (df *documentFragment) InsertBefore(newChild Node, refChild Node) (Node, error) <span class="cov8" title="1">{
        if doc := df.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">result, err := df.node.InsertBefore(newChild, refChild)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Fix the parent reference to be the documentFragment interface
        <span class="cov8" title="1">if nc := getInternalNode(newChild); nc != nil </span><span class="cov8" title="1">{
                nc.parentNode = df
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func (df *documentFragment) AppendChild(newChild Node) (Node, error) <span class="cov8" title="1">{
        return df.InsertBefore(newChild, nil)
}</span>

func (df *documentFragment) RemoveChild(oldChild Node) (Node, error) <span class="cov8" title="1">{
        if doc := df.OwnerDocument(); doc != nil </span><span class="cov8" title="1">{
                if d, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                        d.mu.Lock()
                        defer d.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="1">return df.removeChildInternal(oldChild)</span>
}

// removeChildInternal handles the actual removal without acquiring locks
func (df *documentFragment) removeChildInternal(oldChild Node) (Node, error) <span class="cov8" title="1">{
        parent := oldChild.ParentNode()
        if parent == nil || parent != Node(df) </span><span class="cov0" title="0">{
                return nil, NewDOMException("NotFoundError", "")
        }</span>

        <span class="cov8" title="1">oc := getInternalNode(oldChild)

        if oc.previousSibling != nil </span><span class="cov0" title="0">{
                if prevNode := getInternalNode(oc.previousSibling); prevNode != nil </span><span class="cov0" title="0">{
                        prevNode.nextSibling = oc.nextSibling
                }</span>
        } else<span class="cov8" title="1"> {
                df.firstChild = oc.nextSibling
        }</span>

        <span class="cov8" title="1">if oc.nextSibling != nil </span><span class="cov8" title="1">{
                if nextNode := getInternalNode(oc.nextSibling); nextNode != nil </span><span class="cov8" title="1">{
                        nextNode.previousSibling = oc.previousSibling
                }</span>
        } else<span class="cov8" title="1"> {
                df.lastChild = oc.previousSibling
        }</span>

        <span class="cov8" title="1">oc.parentNode = nil
        oc.nextSibling = nil
        oc.previousSibling = nil

        // Update live NodeList if it exists
        if df.childNodes != nil &amp;&amp; df.childNodes.update != nil </span><span class="cov0" title="0">{
                df.childNodes.update()
        }</span>
        <span class="cov8" title="1">return oldChild, nil</span>
}

// ===========================================================================
// DOMImplementation
// ===========================================================================

// domImplementation provides methods for operations independent of any document instance
type domImplementation struct{}

func NewDOMImplementation() DOMImplementation <span class="cov8" title="1">{
        return &amp;domImplementation{}
}</span>

func (di *domImplementation) HasFeature(feature, version DOMString) bool <span class="cov8" title="1">{
        if versions, ok := supportedFeatures[feature]; ok </span><span class="cov8" title="1">{
                if version == "" </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">for _, v := range versions </span><span class="cov8" title="1">{
                        if v == version </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (di *domImplementation) CreateDocumentType(qualifiedName, publicId, systemId DOMString) (DocumentType, error) <span class="cov8" title="1">{
        return &amp;documentType{
                node: node{
                        nodeType: DOCUMENT_TYPE_NODE,
                        nodeName: qualifiedName,
                },
                name:      qualifiedName,
                publicId:  publicId,
                systemId:  systemId,
                entities:  NewNamedNodeMap(),
                notations: NewNamedNodeMap(),
        }, nil
}</span>

func (di *domImplementation) CreateDocument(namespaceURI, qualifiedName DOMString, doctype DocumentType) (Document, error) <span class="cov8" title="1">{
        doc := &amp;document{
                node: node{
                        nodeType:   DOCUMENT_NODE,
                        nodeName:   "#document",
                        attributes: NewNamedNodeMap(),
                },
                implementation: di,
        }
        doc.node.ownerDocument = doc

        if doctype != nil </span><span class="cov8" title="1">{
                doc.doctype = doctype
        }</span>

        <span class="cov8" title="1">if qualifiedName != "" </span><span class="cov8" title="1">{
                elem, err := doc.CreateElementNS(namespaceURI, qualifiedName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">doc.AppendChild(elem)
                doc.documentElement = elem</span>
        }

        <span class="cov8" title="1">return doc, nil</span>
}

// ===========================================================================
// Helper Functions
// ===========================================================================

// getInternalNode extracts the internal *node from any Node interface implementation
func getInternalNode(n Node) *node <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Handle all concrete types that embed node
        <span class="cov8" title="1">switch v := n.(type) </span>{
        case *node:<span class="cov8" title="1">
                return v</span>
        case *document:<span class="cov8" title="1">
                return &amp;v.node</span>
        case *element:<span class="cov8" title="1">
                return &amp;v.node</span>
        case *attr:<span class="cov0" title="0">
                return &amp;v.node</span>
        case *text:<span class="cov8" title="1">
                return &amp;v.characterData.node</span>
        case *comment:<span class="cov8" title="1">
                return &amp;v.characterData.node</span>
        case *cdataSection:<span class="cov0" title="0">
                return &amp;v.text.characterData.node</span>
        case *documentFragment:<span class="cov0" title="0">
                return &amp;v.node</span>
        case *documentType:<span class="cov0" title="0">
                return &amp;v.node</span>
        case *processingInstruction:<span class="cov8" title="1">
                return &amp;v.node</span>
        case *entity:<span class="cov0" title="0">
                return &amp;v.node</span>
        case *entityReference:<span class="cov0" title="0">
                return &amp;v.node</span>
        case *notation:<span class="cov0" title="0">
                return &amp;v.node</span>
        case *characterData:<span class="cov8" title="1">
                return &amp;v.node</span>
        default:<span class="cov0" title="0">
                // This should not happen if all types are handled
                return nil</span>
        }
}

// isSameNode compares two nodes for identity (same object)
func isSameNode(a, b Node) bool <span class="cov8" title="1">{
        if a == nil || b == nil </span><span class="cov0" title="0">{
                return a == b
        }</span>
        // Compare using reflection to get the actual pointer values
        // This handles the case where *element and *node point to same memory
        <span class="cov8" title="1">aVal := reflect.ValueOf(a)
        bVal := reflect.ValueOf(b)
        if aVal.Kind() == reflect.Ptr &amp;&amp; bVal.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                return aVal.Pointer() == bVal.Pointer()
        }</span>
        <span class="cov0" title="0">return a == b</span>
}

// IsValidName checks if a string is a valid XML Name.
// See https://www.w3.org/TR/xml/#NT-Name
func IsValidName(name DOMString) bool <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i, r := range string(name) </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        if !isNameStartChar(r) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                } else<span class="cov8" title="1"> {
                        if !isNameChar(r) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func isNameStartChar(r rune) bool <span class="cov8" title="1">{
        return r == ':' ||
                (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') ||
                r == '_' ||
                (r &gt;= 'a' &amp;&amp; r &lt;= 'z') ||
                (r &gt;= 0xC0 &amp;&amp; r &lt;= 0xD6) ||
                (r &gt;= 0xD8 &amp;&amp; r &lt;= 0xF6) ||
                (r &gt;= 0xF8 &amp;&amp; r &lt;= 0x2FF) ||
                (r &gt;= 0x370 &amp;&amp; r &lt;= 0x37D) ||
                (r &gt;= 0x37F &amp;&amp; r &lt;= 0x1FFF) ||
                (r &gt;= 0x200C &amp;&amp; r &lt;= 0x200D) ||
                (r &gt;= 0x2070 &amp;&amp; r &lt;= 0x218F) ||
                (r &gt;= 0x2C00 &amp;&amp; r &lt;= 0x2FEF) ||
                (r &gt;= 0x3001 &amp;&amp; r &lt;= 0xD7FF) ||
                (r &gt;= 0xF900 &amp;&amp; r &lt;= 0xFDCF) ||
                (r &gt;= 0xFDF0 &amp;&amp; r &lt;= 0xFFFD) ||
                (r &gt;= 0x10000 &amp;&amp; r &lt;= 0xEFFFF)
}</span>

func isNameChar(r rune) bool <span class="cov8" title="1">{
        return isNameStartChar(r) ||
                r == '-' ||
                r == '.' ||
                (r &gt;= '0' &amp;&amp; r &lt;= '9') ||
                r == 0xB7 ||
                (r &gt;= 0x0300 &amp;&amp; r &lt;= 0x036F) ||
                (r &gt;= 0x203F &amp;&amp; r &lt;= 0x2040)
}</span>

// parseQualifiedName parses a qualified name into prefix and local name
func parseQualifiedName(qualifiedName DOMString) (prefix, localName DOMString) <span class="cov8" title="1">{
        parts := strings.SplitN(string(qualifiedName), ":", 2)
        if len(parts) == 2 </span><span class="cov8" title="1">{
                return DOMString(parts[0]), DOMString(parts[1])
        }</span>
        <span class="cov8" title="1">return "", qualifiedName</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package xmldom

import (
        "encoding/xml"
        "fmt"
        "io"
        "strings"

        "golang.org/x/text/encoding/ianaindex"
)

// Decoder is a struct that decodes a DOM tree from an XML input stream.
//
// CDATA Section Limitation:
// The standard Go encoding/xml package does not differentiate between regular
// character data and CDATA sections. Both are reported as xml.CharData tokens.
// Therefore, this decoder will parse CDATA sections as Text nodes, not as
// CDATASection nodes.
//
// This means that XML like:
//
//        &lt;script&gt;&lt;![CDATA[var x = "&lt;test&gt;";]]&gt;&lt;/script&gt;
//
// will be parsed as if it were:
//
//        &lt;script&gt;var x = "&amp;lt;test&amp;gt;";&lt;/script&gt;
//
// The content is preserved correctly, but the CDATA structure is lost during
// parsing. When the document is serialized back to XML, the content will be
// escaped as regular character data.
//
// To work around this limitation for applications that require true CDATA
// support, create CDATASection nodes manually using Document.CreateCDATASection().
type Decoder struct {
        d             *xml.Decoder
        bufferedToken xml.Token
}

// DecoderOptions allows specifying decoder options.
type DecoderOptions struct {
        // CharsetReader, if non-nil, is used to decode XML input from non-UTF-8 character sets.
        CharsetReader func(charset string, input io.Reader) (io.Reader, error)
        // Strict defaults to true, requiring that XML input be well-formed.
        // If false, the decoder will make a best effort to parse malformed XML.
        Strict bool
        // Entity can be used to provide custom mappings for XML entities.
        Entity map[string]string
}

// NewDecoderWithOptions creates a new Decoder that reads from the given io.Reader
// and uses the provided options.
func NewDecoderWithOptions(r io.Reader, opts *DecoderOptions) *Decoder <span class="cov8" title="1">{
        d := xml.NewDecoder(r)
        if opts != nil </span><span class="cov8" title="1">{
                d.CharsetReader = opts.CharsetReader
                d.Strict = opts.Strict
                d.Entity = opts.Entity
        }</span> else<span class="cov8" title="1"> {
                d.Strict = true
        }</span>

        <span class="cov8" title="1">if d.CharsetReader == nil </span><span class="cov8" title="1">{
                d.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) </span><span class="cov8" title="1">{
                        e, err := ianaindex.IANA.Encoding(charset)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("unsupported charset: %s", charset)
                        }</span>
                        <span class="cov8" title="1">if e == nil </span><span class="cov0" title="0">{
                                // This case can happen if the IANA name is known but the encoding is not available.
                                // For example, the text repo may not include all encodings by default.
                                return nil, fmt.Errorf("unsupported charset: %s", charset)
                        }</span>
                        <span class="cov8" title="1">return e.NewDecoder().Reader(input), nil</span>
                }
        }

        <span class="cov8" title="1">return &amp;Decoder{
                d: d,
        }</span>
}

// NewDecoder creates a new Decoder that reads from the given io.Reader
// with default options.
func NewDecoder(r io.Reader) *Decoder <span class="cov8" title="1">{
        return NewDecoderWithOptions(r, nil)
}</span>

// ParsingError represents an error that occurred during XML parsing.
type ParsingError struct {
        // The underlying error from the xml package.
        Err error
}

func (e *ParsingError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("XML parsing error: %v", e.Err)
}</span>

func (d *Decoder) nextToken() (xml.Token, error) <span class="cov8" title="1">{
        if d.bufferedToken != nil </span><span class="cov8" title="1">{
                token := d.bufferedToken
                d.bufferedToken = nil
                return token, nil
        }</span>
        <span class="cov8" title="1">return d.d.Token()</span>
}

func (d *Decoder) peekToken() (xml.Token, error) <span class="cov8" title="1">{
        if d.bufferedToken != nil </span><span class="cov0" title="0">{
                return d.bufferedToken, nil
        }</span>
        <span class="cov8" title="1">token, err := d.d.Token()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">d.bufferedToken = token
        return token, nil</span>
}

func isValidXMLChar(r rune) bool <span class="cov8" title="1">{
        return r == 0x9 || r == 0xA || r == 0xD ||
                (r &gt;= 0x20 &amp;&amp; r &lt;= 0xD7FF) ||
                (r &gt;= 0xE000 &amp;&amp; r &lt;= 0xFFFD) ||
                (r &gt;= 0x10000 &amp;&amp; r &lt;= 0x10FFFF)
}</span>

// Decode reads the XML from the input stream and returns a Document.
//
// See the Decoder struct documentation for important notes about CDATA sections.
func (d *Decoder) Decode() (Document, error) <span class="cov8" title="1">{
        impl := NewDOMImplementation()
        doc, err := impl.CreateDocument("", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;ParsingError{Err: err}
        }</span>
        <span class="cov8" title="1">docImpl := doc.(*document)

        stack := []Node{doc}

        for </span><span class="cov8" title="1">{
                token, err := d.nextToken()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return nil, &amp;ParsingError{Err: err}
                }</span>

                <span class="cov8" title="1">parent := stack[len(stack)-1]

                switch t := token.(type) </span>{
                case xml.StartElement:<span class="cov8" title="1">
                        // Validate element namespace rules
                        if t.Name.Space == "xmlns" </span><span class="cov8" title="1">{
                                return nil, &amp;ParsingError{Err: fmt.Errorf("elements cannot use xmlns prefix")}
                        }</span>
                        
                        // Create a new element
                        <span class="cov8" title="1">elem, err := doc.CreateElementNS(DOMString(t.Name.Space), DOMString(t.Name.Local))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, &amp;ParsingError{Err: err}
                        }</span>

                        // Copy attributes with namespace validation
                        <span class="cov8" title="1">for _, attr := range t.Attr </span><span class="cov8" title="1">{
                                // Validate namespace prefix rules during parsing
                                if attr.Name.Space == "xmlns" </span><span class="cov8" title="1">{
                                        // This is a namespace declaration: xmlns:prefix="..."
                                        prefix := attr.Name.Local
                                        if prefix == "" </span><span class="cov0" title="0">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("empty prefix in namespace declaration")}
                                        }</span>
                                        <span class="cov8" title="1">if prefix == "xmlns" </span><span class="cov8" title="1">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("cannot declare xmlns prefix")}
                                        }</span>
                                        <span class="cov8" title="1">if prefix == "xml" &amp;&amp; attr.Value != "http://www.w3.org/XML/1998/namespace" </span><span class="cov8" title="1">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("xml prefix must be bound to http://www.w3.org/XML/1998/namespace")}
                                        }</span>
                                        <span class="cov8" title="1">if attr.Value == "http://www.w3.org/XML/1998/namespace" &amp;&amp; prefix != "xml" </span><span class="cov8" title="1">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("http://www.w3.org/XML/1998/namespace can only be bound to xml prefix")}
                                        }</span>
                                } else<span class="cov8" title="1"> if attr.Name.Space == "" &amp;&amp; attr.Name.Local == "xmlns" </span><span class="cov8" title="1">{
                                        // Default namespace declaration: xmlns="..."
                                        if attr.Value == "http://www.w3.org/2000/xmlns/" </span><span class="cov0" title="0">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("cannot bind default namespace to xmlns namespace")}
                                        }</span>
                                } else<span class="cov8" title="1"> if attr.Name.Space == "" &amp;&amp; strings.HasPrefix(attr.Name.Local, "xmlns:") </span><span class="cov8" title="1">{
                                        // Malformed namespace declaration: xmlns:=""
                                        if attr.Name.Local == "xmlns:" </span><span class="cov8" title="1">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("empty prefix in namespace declaration")}
                                        }</span>
                                        // Extract the prefix after xmlns:
                                        <span class="cov0" title="0">prefix := attr.Name.Local[6:] // Remove "xmlns:" prefix
                                        if prefix == "xmlns" </span><span class="cov0" title="0">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("cannot declare xmlns prefix")}
                                        }</span>
                                        <span class="cov0" title="0">if prefix == "xml" &amp;&amp; attr.Value != "http://www.w3.org/XML/1998/namespace" </span><span class="cov0" title="0">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("xml prefix must be bound to http://www.w3.org/XML/1998/namespace")}
                                        }</span>
                                        <span class="cov0" title="0">if attr.Value == "http://www.w3.org/XML/1998/namespace" &amp;&amp; prefix != "xml" </span><span class="cov0" title="0">{
                                                return nil, &amp;ParsingError{Err: fmt.Errorf("http://www.w3.org/XML/1998/namespace can only be bound to xml prefix")}
                                        }</span>
                                }
                                
                                <span class="cov8" title="1">err := elem.SetAttributeNS(DOMString(attr.Name.Space), DOMString(attr.Name.Local), DOMString(attr.Value))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, &amp;ParsingError{Err: err}
                                }</span>
                        }

                        // Append the new element to the parent
                        <span class="cov8" title="1">parent.AppendChild(elem)

                        // Peek at the next token to see if it's a matching end element.
                        nextToken, err := d.peekToken()
                        if err != nil </span><span class="cov8" title="1">{
                                if err == io.EOF </span>{<span class="cov0" title="0">
                                        // This is a valid case for the last element in the document.
                                }</span> else<span class="cov8" title="1"> {
                                        return nil, &amp;ParsingError{Err: err}
                                }</span>
                        }

                        <span class="cov8" title="1">if end, ok := nextToken.(xml.EndElement); ok &amp;&amp; end.Name == t.Name </span><span class="cov8" title="1">{
                                // This is a self-closing element. Consume the end token.
                                _, _ = d.nextToken()
                        }</span> else<span class="cov8" title="1"> {
                                // This is a regular start element. Push it onto the stack.
                                stack = append(stack, elem)
                        }</span>

                        <span class="cov8" title="1">if docImpl.documentElement == nil </span><span class="cov0" title="0">{
                                docImpl.documentElement = elem
                        }</span>
                case xml.EndElement:<span class="cov8" title="1">
                        stack = stack[:len(stack)-1]</span>
                case xml.CharData:<span class="cov8" title="1">
                        for _, r := range string(t) </span><span class="cov8" title="1">{
                                if !isValidXMLChar(r) </span><span class="cov0" title="0">{
                                        return nil, &amp;ParsingError{Err: fmt.Errorf("invalid character 0x%x in CharData", r)}
                                }</span>
                        }
                        <span class="cov8" title="1">text := doc.CreateTextNode(DOMString(t))
                        parent.AppendChild(text)</span>
                case xml.Comment:<span class="cov8" title="1">
                        commentText := DOMString(t)
                        for _, r := range commentText </span><span class="cov8" title="1">{
                                if !isValidXMLChar(r) </span><span class="cov8" title="1">{
                                        return nil, &amp;ParsingError{Err: fmt.Errorf("invalid character 0x%x in comment", r)}
                                }</span>
                        }
                        <span class="cov8" title="1">if strings.Contains(string(commentText), "--") </span><span class="cov0" title="0">{
                                return nil, &amp;ParsingError{Err: fmt.Errorf("comment contains '--'")}
                        }</span>
                        <span class="cov8" title="1">comment := doc.CreateComment(commentText)
                        parent.AppendChild(comment)</span>
                case xml.ProcInst:<span class="cov8" title="1">
                        // The Go XML parser reports the XML declaration as a ProcInst with target "xml".
                        // We need to ignore this, as it's not a real processing instruction.
                        if strings.EqualFold(t.Target, "xml") </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, r := range string(t.Inst) </span><span class="cov8" title="1">{
                                if !isValidXMLChar(r) </span><span class="cov8" title="1">{
                                        return nil, &amp;ParsingError{Err: fmt.Errorf("invalid character 0x%x in processing instruction", r)}
                                }</span>
                        }
                        <span class="cov8" title="1">pi, err := doc.CreateProcessingInstruction(DOMString(t.Target), DOMString(t.Inst))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, &amp;ParsingError{Err: err}
                        }</span>
                        <span class="cov8" title="1">parent.AppendChild(pi)</span>
                case xml.Directive:<span class="cov8" title="1">
                        s := string(t)
                        // Check for invalid characters in the directive itself
                        for _, r := range s </span><span class="cov8" title="1">{
                                if !isValidXMLChar(r) </span><span class="cov8" title="1">{
                                        return nil, &amp;ParsingError{Err: fmt.Errorf("invalid character 0x%x in directive", r)}
                                }</span>
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(s, "DOCTYPE") </span><span class="cov8" title="1">{
                                s = strings.TrimSpace(s[len("DOCTYPE"):])

                                var name, publicId, systemId string

                                // Extract name
                                nameEnd := strings.IndexAny(s, " \t\n\r[")
                                if nameEnd == -1 </span><span class="cov0" title="0">{
                                        name = s
                                        s = ""
                                }</span> else<span class="cov8" title="1"> {
                                        name = s[:nameEnd]
                                        s = strings.TrimSpace(s[nameEnd:])
                                }</span>

                                <span class="cov8" title="1">if strings.HasPrefix(s, "PUBLIC") </span><span class="cov8" title="1">{
                                        s = strings.TrimSpace(s[len("PUBLIC"):])
                                        if len(s) &gt; 0 &amp;&amp; s[0] == '"' </span><span class="cov8" title="1">{
                                                end := strings.Index(s[1:], "\"")
                                                if end != -1 </span><span class="cov8" title="1">{
                                                        publicId = s[1 : end+1]
                                                        s = strings.TrimSpace(s[end+2:])
                                                        if len(s) &gt; 0 &amp;&amp; s[0] == '"' </span><span class="cov8" title="1">{
                                                                end = strings.Index(s[1:], "\"")
                                                                if end != -1 </span><span class="cov8" title="1">{
                                                                        systemId = s[1 : end+1]
                                                                }</span>
                                                        }
                                                }
                                        }
                                } else<span class="cov8" title="1"> if strings.HasPrefix(s, "SYSTEM") </span><span class="cov8" title="1">{
                                        s = strings.TrimSpace(s[len("SYSTEM"):])
                                        if len(s) &gt; 0 &amp;&amp; s[0] == '"' </span><span class="cov8" title="1">{
                                                end := strings.Index(s[1:], "\"")
                                                if end != -1 </span><span class="cov8" title="1">{
                                                        systemId = s[1 : end+1]
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">doctype, err := doc.Implementation().CreateDocumentType(DOMString(name), DOMString(publicId), DOMString(systemId))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, &amp;ParsingError{Err: err}
                                }</span>
                                <span class="cov8" title="1">if docImpl, ok := doc.(*document); ok </span><span class="cov8" title="1">{
                                        docImpl.doctype = doctype
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return doc, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package xmldom

import (
        "encoding/xml"
        "fmt"
        "io"
)

// Encoder writes DOM nodes as XML to an output stream.
type Encoder struct {
        e *xml.Encoder
        w io.Writer
}

// NewEncoder returns a new encoder that writes to w.
func NewEncoder(w io.Writer) *Encoder <span class="cov8" title="1">{
        enc := &amp;Encoder{
                e: xml.NewEncoder(w),
                w: w,
        }
        enc.e.Indent("", "  ")
        return enc
}</span>

// SetIndent sets the indentation for the encoder.
// The prefix is written at the beginning of each line except the first.
// The indent string is written for each level of indentation.
func (enc *Encoder) SetIndent(prefix, indent string) <span class="cov0" title="0">{
        enc.e.Indent(prefix, indent)
}</span>

// Encode writes the XML encoding of node to the stream.
func (enc *Encoder) Encode(node Node) error <span class="cov8" title="1">{
        if node.NodeType() == DOCUMENT_NODE </span><span class="cov8" title="1">{
                doc := node.(Document)
                if doc.Doctype() != nil </span><span class="cov0" title="0">{
                        if err := enc.encodeDoctype(doc.Doctype()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if err := enc.encodeNode(node); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return enc.e.Flush()</span>
}

func (enc *Encoder) encodeNode(node Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch node.NodeType() </span>{
        case ELEMENT_NODE:<span class="cov8" title="1">
                return enc.encodeElement(node.(Element))</span>

        case TEXT_NODE:<span class="cov8" title="1">
                return enc.e.EncodeToken(xml.CharData(node.NodeValue()))</span>

        case COMMENT_NODE:<span class="cov0" title="0">
                return enc.e.EncodeToken(xml.Comment(node.NodeValue()))</span>

        case CDATA_SECTION_NODE:<span class="cov0" title="0">
                // CDATA sections must be written manually since Go's xml.Encoder
                // doesn't provide a CDATA token type and would escape the content
                // if we used xml.CharData
                _, err := fmt.Fprintf(enc.w, "&lt;![CDATA[%s]]&gt;", string(node.NodeValue()))
                return err</span>

        case PROCESSING_INSTRUCTION_NODE:<span class="cov0" title="0">
                pi := node.(ProcessingInstruction)
                return enc.e.EncodeToken(xml.ProcInst{
                        Target: string(pi.Target()),
                        Inst:   []byte(pi.Data()),
                })</span>

        case DOCUMENT_NODE:<span class="cov8" title="1">
                // Encode children
                for child := node.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                        if err := enc.encodeNode(child); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case DOCUMENT_FRAGMENT_NODE:<span class="cov0" title="0">
                // Encode children
                for child := node.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov0" title="0">{
                        if err := enc.encodeNode(child); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (enc *Encoder) encodeElement(elem Element) error <span class="cov8" title="1">{
        // Create start element
        start := xml.StartElement{
                Name: xml.Name{
                        Space: string(elem.NamespaceURI()),
                        Local: string(elem.LocalName()),
                },
        }

        // Add attributes
        if attrs := elem.Attributes(); attrs != nil </span><span class="cov8" title="1">{
                for i := uint(0); i &lt; attrs.Length(); i++ </span><span class="cov8" title="1">{
                        attr := attrs.Item(i)
                        if attr != nil &amp;&amp; attr.NodeType() == ATTRIBUTE_NODE </span><span class="cov8" title="1">{
                                a := attr.(Attr)
                                start.Attr = append(start.Attr, xml.Attr{
                                        Name: xml.Name{
                                                Space: string(attr.NamespaceURI()),
                                                Local: string(a.LocalName()),
                                        },
                                        Value: string(a.Value()),
                                })
                        }</span>
                }
        }

        // Encode start element
        <span class="cov8" title="1">if err := enc.e.EncodeToken(start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Encode children
        <span class="cov8" title="1">for child := elem.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                if err := enc.encodeNode(child); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Encode end element
        <span class="cov8" title="1">return enc.e.EncodeToken(xml.EndElement{Name: start.Name})</span>
}

func (enc *Encoder) encodeDoctype(doctype DocumentType) error <span class="cov0" title="0">{
        // XML encoder doesn't support DOCTYPE directly, write as string
        // This is a simplified approach
        docStr := "&lt;!DOCTYPE " + string(doctype.Name())
        if doctype.PublicId() != "" </span><span class="cov0" title="0">{
                docStr += " PUBLIC \"" + string(doctype.PublicId()) + "\""
                if doctype.SystemId() != "" </span><span class="cov0" title="0">{
                        docStr += " \"" + string(doctype.SystemId()) + "\""
                }</span>
        } else<span class="cov0" title="0"> if doctype.SystemId() != "" </span><span class="cov0" title="0">{
                docStr += " SYSTEM \"" + string(doctype.SystemId()) + "\""
        }</span>
        <span class="cov0" title="0">docStr += "&gt;"

        // Write directly as a comment (workaround for XML encoder limitation)
        return enc.e.EncodeToken(xml.Comment(docStr))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package xmldom

import (
        "io"
        "strings"
)

// EscapeText writes to w the properly escaped XML equivalent of plain text data.
// This function implements XML 1.0 Fifth Edition, Section 2.4 character escaping rules
// and DOM Level 2+ Core specification requirements for character data handling.
//
// For compatibility with encoding/xml.EscapeText, the following characters are escaped:
// - '&lt;' as &amp;lt;
// - '&gt;' as &amp;gt; (required in text content for compatibility)
// - '&amp;' as &amp;amp;
// - '"' as &amp;#34; (numeric character reference for compatibility)
// - '\'' as &amp;#39; (numeric character reference for compatibility)
// - '\t' as &amp;#x9; (numeric character reference for tab)
// - '\n' as &amp;#xA; (numeric character reference for newline)
// - '\r' as &amp;#xD; (numeric character reference for carriage return)
//
// Characters outside the valid XML character range are replaced with the Unicode replacement character.
// This function provides full compatibility with encoding/xml.EscapeText while ensuring
// DOM specification compliance for character data handling.
func EscapeText(w io.Writer, s []byte) error <span class="cov8" title="1">{
        var esc []byte
        last := 0
        for i, c := range s </span><span class="cov8" title="1">{
                switch c </span>{
                case '&lt;':<span class="cov8" title="1">
                        esc = []byte("&amp;lt;")</span>
                case '&gt;':<span class="cov8" title="1">
                        esc = []byte("&amp;gt;")</span>
                case '&amp;':<span class="cov8" title="1">
                        esc = []byte("&amp;amp;")</span>
                case '"':<span class="cov8" title="1">
                        esc = []byte("&amp;#34;")</span>
                case '\'':<span class="cov8" title="1">
                        esc = []byte("&amp;#39;")</span>
                case '\t':<span class="cov8" title="1">
                        esc = []byte("&amp;#x9;")</span>
                case '\n':<span class="cov8" title="1">
                        esc = []byte("&amp;#xA;")</span>
                case '\r':<span class="cov8" title="1">
                        esc = []byte("&amp;#xD;")</span>
                default:<span class="cov8" title="1">
                        // Handle invalid XML characters (control characters except tab, newline, carriage return)
                        if c &lt; 0x20 &amp;&amp; c != 0x09 &amp;&amp; c != 0x0A &amp;&amp; c != 0x0D </span><span class="cov8" title="1">{
                                // Replace invalid characters with Unicode replacement character (U+FFFD)
                                // In UTF-8, this is the 3-byte sequence: 0xEF 0xBF 0xBD
                                esc = []byte("\uFFFD")
                        }</span> else<span class="cov8" title="1"> {
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if _, err := w.Write(s[last:i]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.Write(esc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">last = i + 1</span>
        }
        <span class="cov8" title="1">_, err := w.Write(s[last:])
        return err</span>
}

// EscapeString returns the properly escaped XML equivalent of plain text data.
// This is a convenience function that wraps EscapeText for string input/output.
//
// Per XML 1.0 Fifth Edition Section 2.4 and DOM Level 2+ Core specification,
// this escapes all XML special characters to ensure valid character data representation.
func EscapeString(s string) string <span class="cov8" title="1">{
        var b strings.Builder
        if err := EscapeText(&amp;b, []byte(s)); err != nil </span><span class="cov0" title="0">{
                // strings.Builder.Write never returns an error, so this should never happen
                panic("unexpected error from strings.Builder.Write: " + err.Error())</span>
        }
        <span class="cov8" title="1">return b.String()</span>
}

// UnescapeText decodes XML character entity references in text data.
// This function reverses the escaping performed by EscapeText.
//
// It handles both named entity references and numeric character references:
// - &amp;lt; -&gt; '&lt;'
// - &amp;gt; -&gt; '&gt;'
// - &amp;amp; -&gt; '&amp;'
// - &amp;quot; or &amp;#34; -&gt; '"'
// - &amp;apos; or &amp;#39; -&gt; '\''
// - &amp;#x9; -&gt; '\t'
// - &amp;#xA; -&gt; '\n'
// - &amp;#xD; -&gt; '\r'
//
// This function is provided for completeness and round-trip compatibility.
func UnescapeText(w io.Writer, s []byte) error <span class="cov8" title="1">{
        last := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if s[i] == '&amp;' </span><span class="cov8" title="1">{
                        if _, err := w.Write(s[last:i]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        
                        // Find the end of the entity reference
                        <span class="cov8" title="1">end := i + 1
                        for end &lt; len(s) &amp;&amp; s[end] != ';' </span><span class="cov8" title="1">{
                                end++
                        }</span>
                        
                        <span class="cov8" title="1">if end &gt;= len(s) </span><span class="cov8" title="1">{
                                // No closing semicolon found, write as-is
                                if _, err := w.Write(s[i:i+1]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">last = i + 1
                                continue</span>
                        }
                        
                        <span class="cov8" title="1">entity := string(s[i+1 : end])
                        var replacement byte
                        var replacementStr string
                        handled := false
                        
                        switch entity </span>{
                        case "lt":<span class="cov8" title="1">
                                replacement = '&lt;'
                                handled = true</span>
                        case "gt":<span class="cov8" title="1">
                                replacement = '&gt;'
                                handled = true</span>
                        case "amp":<span class="cov8" title="1">
                                replacement = '&amp;'
                                handled = true</span>
                        case "quot", "#34":<span class="cov8" title="1">
                                replacement = '"'
                                handled = true</span>
                        case "apos", "#39":<span class="cov8" title="1">
                                replacement = '\''
                                handled = true</span>
                        case "#x9":<span class="cov8" title="1">
                                replacement = '\t'
                                handled = true</span>
                        case "#xA":<span class="cov8" title="1">
                                replacement = '\n'
                                handled = true</span>
                        case "#xD":<span class="cov0" title="0">
                                replacement = '\r'
                                handled = true</span>
                        default:<span class="cov8" title="1">
                                // Check for Unicode replacement character
                                if entity == "#xFFFD" </span><span class="cov0" title="0">{
                                        replacementStr = "\uFFFD"
                                        handled = true
                                }</span>
                        }
                        
                        <span class="cov8" title="1">if handled </span><span class="cov8" title="1">{
                                if replacementStr != "" </span><span class="cov0" title="0">{
                                        if _, err := w.Write([]byte(replacementStr)); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        if _, err := w.Write([]byte{replacement}); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                // Unknown entity, write as-is
                                if _, err := w.Write(s[i:end+1]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        
                        <span class="cov8" title="1">last = end + 1
                        i = end</span>
                }
        }
        <span class="cov8" title="1">_, err := w.Write(s[last:])
        return err</span>
}

// UnescapeString returns the decoded XML equivalent of escaped text data.
// This is a convenience function that wraps UnescapeText for string input/output.
func UnescapeString(s string) string <span class="cov8" title="1">{
        var b strings.Builder
        if err := UnescapeText(&amp;b, []byte(s)); err != nil </span><span class="cov0" title="0">{
                // strings.Builder.Write never returns an error, so this should never happen
                panic("unexpected error from strings.Builder.Write: " + err.Error())</span>
        }
        <span class="cov8" title="1">return b.String()</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package xmldom

import (
        "bytes"
        "encoding/xml"
        "strings"
)

// Unmarshal parses XML-encoded data and stores the result in the value pointed to by v.
// This function delegates to Go's standard xml.Unmarshal for struct unmarshaling.
func Unmarshal(data []byte, v interface{}) error <span class="cov8" title="1">{
        return xml.Unmarshal(data, v)
}</span>

// UnmarshalDOM parses XML-encoded data and returns a DOM Document.
// This creates a DOM tree that can be manipulated using the xmldom API.
func UnmarshalDOM(data []byte) (Document, error) <span class="cov8" title="1">{
        decoder := NewDecoder(strings.NewReader(string(data)))
        return decoder.Decode()
}</span>

// Marshal returns the XML encoding of v.
// This function handles both DOM Documents and regular structs.
func Marshal(v interface{}) ([]byte, error) <span class="cov8" title="1">{
        // Check if v is a DOM Document
        if doc, ok := v.(Document); ok </span><span class="cov8" title="1">{
                return marshalDOM(doc)
        }</span>
        // For non-DOM objects, delegate to Go's standard xml.Marshal
        <span class="cov8" title="1">return xml.Marshal(v)</span>
}

// marshalDOM serializes a DOM Document to XML
func marshalDOM(doc Document) ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer

        // Write XML declaration
        buf.WriteString(`&lt;?xml version="1.0"?&gt;`)

        // Serialize the document element
        root := doc.DocumentElement()
        if root == nil </span><span class="cov0" title="0">{
                return buf.Bytes(), nil // Empty document
        }</span>

        <span class="cov8" title="1">if err := serializeElement(&amp;buf, root, false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// serializeElement serializes an Element and its children to XML
func serializeElement(buf *bytes.Buffer, elem Element, skipRoot bool) error <span class="cov8" title="1">{
        if !skipRoot </span><span class="cov8" title="1">{
                // Write opening tag
                buf.WriteString("&lt;")
                buf.WriteString(string(elem.TagName()))

                // Write attributes
                attrs := elem.Attributes()
                if attrs != nil </span><span class="cov8" title="1">{
                        for i := uint(0); i &lt; attrs.Length(); i++ </span><span class="cov8" title="1">{
                                attr := attrs.Item(i)
                                if attr != nil &amp;&amp; attr.NodeType() == ATTRIBUTE_NODE </span><span class="cov8" title="1">{
                                        if attrNode, ok := attr.(Attr); ok </span><span class="cov8" title="1">{
                                                buf.WriteString(" ")
                                                buf.WriteString(string(attrNode.Name()))
                                                buf.WriteString(`="`)
                                                buf.WriteString(EscapeString(string(attrNode.Value())))
                                                buf.WriteString(`"`)
                                        }</span>
                                }
                        }
                }

                // Check if element has children
                <span class="cov8" title="1">hasChildren := elem.HasChildNodes()
                if !hasChildren </span><span class="cov8" title="1">{
                        buf.WriteString("/&gt;")
                        return nil
                }</span>

                <span class="cov8" title="1">buf.WriteString("&gt;")</span>
        }

        // Serialize children
        <span class="cov8" title="1">for child := elem.FirstChild(); child != nil; child = child.NextSibling() </span><span class="cov8" title="1">{
                if err := serializeNode(buf, child); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if !skipRoot </span><span class="cov8" title="1">{
                // Write closing tag
                buf.WriteString("&lt;/")
                buf.WriteString(string(elem.TagName()))
                buf.WriteString("&gt;")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// serializeNode serializes any DOM node to XML
func serializeNode(buf *bytes.Buffer, node Node) error <span class="cov8" title="1">{
        switch node.NodeType() </span>{
        case ELEMENT_NODE:<span class="cov8" title="1">
                if elem, ok := node.(Element); ok </span><span class="cov8" title="1">{
                        return serializeElement(buf, elem, false)
                }</span>
        case TEXT_NODE:<span class="cov8" title="1">
                if text, ok := node.(Text); ok </span><span class="cov8" title="1">{
                        buf.WriteString(EscapeString(string(text.Data())))
                }</span>
        case COMMENT_NODE:<span class="cov8" title="1">
                if comment, ok := node.(Comment); ok </span><span class="cov8" title="1">{
                        buf.WriteString("&lt;!--")
                        buf.WriteString(string(comment.Data()))
                        buf.WriteString("--&gt;")
                }</span>
        case CDATA_SECTION_NODE:<span class="cov0" title="0">
                if cdata, ok := node.(CDATASection); ok </span><span class="cov0" title="0">{
                        buf.WriteString("&lt;![CDATA[")
                        buf.WriteString(string(cdata.Data()))
                        buf.WriteString("]]&gt;")
                }</span>
        case PROCESSING_INSTRUCTION_NODE:<span class="cov0" title="0">
                if pi, ok := node.(ProcessingInstruction); ok </span><span class="cov0" title="0">{
                        buf.WriteString("&lt;?")
                        buf.WriteString(string(pi.Target()))
                        if data := string(pi.Data()); data != "" </span><span class="cov0" title="0">{
                                buf.WriteString(" ")
                                buf.WriteString(data)
                        }</span>
                        <span class="cov0" title="0">buf.WriteString("?&gt;")</span>
                }
        // Skip other node types for now
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package xmldom

import (
        "context"
        "fmt"
        "sync"
)

// XPath result type constants matching DOM Living Standard
// https://dom.spec.whatwg.org/#xpath
const (
        XPATH_ANY_TYPE                    uint16 = 0
        XPATH_NUMBER_TYPE                 uint16 = 1
        XPATH_STRING_TYPE                 uint16 = 2
        XPATH_BOOLEAN_TYPE                uint16 = 3
        XPATH_UNORDERED_NODE_ITERATOR_TYPE uint16 = 4
        XPATH_ORDERED_NODE_ITERATOR_TYPE   uint16 = 5
        XPATH_UNORDERED_NODE_SNAPSHOT_TYPE uint16 = 6
        XPATH_ORDERED_NODE_SNAPSHOT_TYPE   uint16 = 7
        XPATH_ANY_UNORDERED_NODE_TYPE     uint16 = 8
        XPATH_FIRST_ORDERED_NODE_TYPE     uint16 = 9
)

// XPathValue represents the fundamental XPath 1.0 data types
// All XPath expressions evaluate to one of these four types
type XPathValue interface {
        Type() XPathValueType
        String() string
        Number() float64
        Boolean() bool
        NodeSet() []Node
}

// XPathValueType represents the four fundamental XPath 1.0 types
type XPathValueType uint8

const (
        XPathValueTypeString  XPathValueType = iota
        XPathValueTypeNumber
        XPathValueTypeBoolean
        XPathValueTypeNodeSet
)

// XPathResult interface matching DOM Living Standard
// Provides access to XPath evaluation results in various formats
type XPathResult interface {
        // Result type and basic values
        ResultType() uint16
        NumberValue() (float64, error)
        StringValue() (string, error)
        BooleanValue() (bool, error)
        SingleNodeValue() (Node, error)

        // Iterator state and operations
        InvalidIteratorState() bool
        IterateNext() (Node, error)

        // Snapshot operations
        SnapshotLength() (uint32, error)
        SnapshotItem(index uint32) (Node, error)
}

// XPathExpression represents a compiled XPath expression
// Following DOM Living Standard for performance optimization
type XPathExpression interface {
        // Evaluate the compiled expression against a context node
        Evaluate(contextNode Node, resultType uint16, result XPathResult) (XPathResult, error)
}

// XPathNSResolver provides namespace resolution for XPath expressions
// Callback interface matching DOM Living Standard
type XPathNSResolver interface {
        LookupNamespaceURI(prefix string) string
}

// XPathEvaluatorBase defines the core XPath evaluation methods
// This will be mixed into the Document interface
type XPathEvaluatorBase interface {
        // Create a compiled XPath expression for reuse
        CreateExpression(expression string, resolver XPathNSResolver) (XPathExpression, error)

        // Create namespace resolver (legacy compatibility)
        CreateNSResolver(nodeResolver Node) Node

        // Evaluate XPath expression directly
        Evaluate(expression string, contextNode Node, resolver XPathNSResolver,
                resultType uint16, result XPathResult) (XPathResult, error)
}

// Internal XPath data structures

// xpathStringValue implements XPathValue for string results
type xpathStringValue struct {
        value string
}

func (v xpathStringValue) Type() XPathValueType <span class="cov0" title="0">{ return XPathValueTypeString }</span>
func (v xpathStringValue) String() string       <span class="cov0" title="0">{ return v.value }</span>
func (v xpathStringValue) Number() float64      <span class="cov0" title="0">{ return stringToNumber(v.value) }</span>
func (v xpathStringValue) Boolean() bool        <span class="cov0" title="0">{ return v.value != "" }</span>
func (v xpathStringValue) NodeSet() []Node      <span class="cov0" title="0">{ return nil }</span>

// xpathNumberValue implements XPathValue for numeric results
type xpathNumberValue struct {
        value float64
}

func (v xpathNumberValue) Type() XPathValueType <span class="cov0" title="0">{ return XPathValueTypeNumber }</span>
func (v xpathNumberValue) String() string       <span class="cov0" title="0">{ return numberToString(v.value) }</span>
func (v xpathNumberValue) Number() float64      <span class="cov0" title="0">{ return v.value }</span>
func (v xpathNumberValue) Boolean() bool        <span class="cov0" title="0">{ return v.value != 0 &amp;&amp; !isNaN(v.value) }</span>
func (v xpathNumberValue) NodeSet() []Node      <span class="cov0" title="0">{ return nil }</span>

// xpathBooleanValue implements XPathValue for boolean results
type xpathBooleanValue struct {
        value bool
}

func (v xpathBooleanValue) Type() XPathValueType <span class="cov0" title="0">{ return XPathValueTypeBoolean }</span>
func (v xpathBooleanValue) String() string       <span class="cov0" title="0">{ return booleanToString(v.value) }</span>
func (v xpathBooleanValue) Number() float64      <span class="cov0" title="0">{ return booleanToNumber(v.value) }</span>
func (v xpathBooleanValue) Boolean() bool        <span class="cov0" title="0">{ return v.value }</span>
func (v xpathBooleanValue) NodeSet() []Node      <span class="cov0" title="0">{ return nil }</span>

// xpathNodeSetValue implements XPathValue for node-set results
type xpathNodeSetValue struct {
        nodes []Node
}

func (v xpathNodeSetValue) Type() XPathValueType <span class="cov0" title="0">{ return XPathValueTypeNodeSet }</span>
func (v xpathNodeSetValue) String() string       <span class="cov0" title="0">{ return nodeSetToString(v.nodes) }</span>
func (v xpathNodeSetValue) Number() float64      <span class="cov0" title="0">{ return stringToNumber(v.String()) }</span>
func (v xpathNodeSetValue) Boolean() bool        <span class="cov0" title="0">{ return len(v.nodes) &gt; 0 }</span>
func (v xpathNodeSetValue) NodeSet() []Node      <span class="cov0" title="0">{ return v.nodes }</span>

// XPathResult implementation

// xpathResult implements the XPathResult interface
type xpathResult struct {
        resultType    uint16
        value         XPathValue
        iterator      *xpathNodeIterator
        snapshot      []Node
        invalidState  bool
        mu            sync.RWMutex // Protect iterator state
}

func (r *xpathResult) ResultType() uint16 <span class="cov0" title="0">{
        return r.resultType
}</span>

func (r *xpathResult) NumberValue() (float64, error) <span class="cov0" title="0">{
        if r.resultType != XPATH_NUMBER_TYPE </span><span class="cov0" title="0">{
                return 0, NewXPathException("TYPE_ERR", "Result is not a number")
        }</span>
        <span class="cov0" title="0">return r.value.Number(), nil</span>
}

func (r *xpathResult) StringValue() (string, error) <span class="cov0" title="0">{
        if r.resultType != XPATH_STRING_TYPE </span><span class="cov0" title="0">{
                return "", NewXPathException("TYPE_ERR", "Result is not a string")
        }</span>
        <span class="cov0" title="0">return r.value.String(), nil</span>
}

func (r *xpathResult) BooleanValue() (bool, error) <span class="cov0" title="0">{
        if r.resultType != XPATH_BOOLEAN_TYPE </span><span class="cov0" title="0">{
                return false, NewXPathException("TYPE_ERR", "Result is not a boolean")
        }</span>
        <span class="cov0" title="0">return r.value.Boolean(), nil</span>
}

func (r *xpathResult) SingleNodeValue() (Node, error) <span class="cov0" title="0">{
        switch r.resultType </span>{
        case XPATH_ANY_UNORDERED_NODE_TYPE, XPATH_FIRST_ORDERED_NODE_TYPE:<span class="cov0" title="0">
                if nodes := r.value.NodeSet(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                        return nodes[0], nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "Result is not a single node")</span>
}

func (r *xpathResult) InvalidIteratorState() bool <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.invalidState
}</span>

func (r *xpathResult) IterateNext() (Node, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.invalidState </span><span class="cov0" title="0">{
                return nil, NewXPathException("INVALID_STATE_ERR", "Iterator is in invalid state")
        }</span>

        <span class="cov0" title="0">switch r.resultType </span>{
        case XPATH_UNORDERED_NODE_ITERATOR_TYPE, XPATH_ORDERED_NODE_ITERATOR_TYPE:<span class="cov0" title="0">
                if r.iterator != nil </span><span class="cov0" title="0">{
                        return r.iterator.nextNode(), nil
                }</span>
        }
        <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "Result is not an iterator")</span>
}

func (r *xpathResult) SnapshotLength() (uint32, error) <span class="cov0" title="0">{
        switch r.resultType </span>{
        case XPATH_UNORDERED_NODE_SNAPSHOT_TYPE, XPATH_ORDERED_NODE_SNAPSHOT_TYPE:<span class="cov0" title="0">
                return uint32(len(r.snapshot)), nil</span>
        }
        <span class="cov0" title="0">return 0, NewXPathException("TYPE_ERR", "Result is not a snapshot")</span>
}

func (r *xpathResult) SnapshotItem(index uint32) (Node, error) <span class="cov0" title="0">{
        switch r.resultType </span>{
        case XPATH_UNORDERED_NODE_SNAPSHOT_TYPE, XPATH_ORDERED_NODE_SNAPSHOT_TYPE:<span class="cov0" title="0">
                if int(index) &lt; len(r.snapshot) </span><span class="cov0" title="0">{
                        return r.snapshot[index], nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "Result is not a snapshot")</span>
}

// xpathNodeIterator provides iteration over node sets
type xpathNodeIterator struct {
        nodes []Node
        index int
}

func (it *xpathNodeIterator) nextNode() Node <span class="cov0" title="0">{
        if it.index &gt;= len(it.nodes) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">node := it.nodes[it.index]
        it.index++
        return node</span>
}

// Factory functions following Go naming conventions

// NewXPathResult creates a new XPathResult (pointer type)
func NewXPathResult(resultType uint16, value XPathValue) XPathResult <span class="cov0" title="0">{
        result := &amp;xpathResult{
                resultType: resultType,
                value:     value,
        }

        // Configure based on result type
        switch resultType </span>{
        case XPATH_UNORDERED_NODE_ITERATOR_TYPE, XPATH_ORDERED_NODE_ITERATOR_TYPE:<span class="cov0" title="0">
                if nodes := value.NodeSet(); nodes != nil </span><span class="cov0" title="0">{
                        result.iterator = &amp;xpathNodeIterator{nodes: nodes}
                }</span>
        case XPATH_UNORDERED_NODE_SNAPSHOT_TYPE, XPATH_ORDERED_NODE_SNAPSHOT_TYPE:<span class="cov0" title="0">
                result.snapshot = value.NodeSet()</span>
        }

        <span class="cov0" title="0">return result</span>
}

// NewXPathStringValue creates a string XPathValue
func NewXPathStringValue(s string) XPathValue <span class="cov0" title="0">{
        return xpathStringValue{value: s}
}</span>

// NewXPathNumberValue creates a number XPathValue
func NewXPathNumberValue(n float64) XPathValue <span class="cov0" title="0">{
        return xpathNumberValue{value: n}
}</span>

// NewXPathBooleanValue creates a boolean XPathValue
func NewXPathBooleanValue(b bool) XPathValue <span class="cov0" title="0">{
        return xpathBooleanValue{value: b}
}</span>

// NewXPathNodeSetValue creates a node-set XPathValue
func NewXPathNodeSetValue(nodes []Node) XPathValue <span class="cov0" title="0">{
        return xpathNodeSetValue{nodes: nodes}
}</span>

// XPath AST node types for internal representation

// XPathNode represents a node in the XPath AST
type XPathNode interface {
        Type() XPathNodeType
        Evaluate(ctx *XPathContext) (XPathValue, error)
}

// XPathNodeType represents different types of AST nodes
type XPathNodeType uint8

const (
        XPathNodeTypePath      XPathNodeType = iota
        XPathNodeTypeAxis
        XPathNodeTypeFunction
        XPathNodeTypeLiteral
        XPathNodeTypeBinary
        XPathNodeTypeUnary
        XPathNodeTypePredicate
        XPathNodeTypeFilter
)

// XPathContext provides evaluation context for XPath expressions
type XPathContext struct {
        ContextNode       Node
        ContextSize       int
        ContextPosition   int
        VariableBindings  map[string]XPathValue
        FunctionLibrary   map[string]XPathFunction
        NamespaceResolver XPathNSResolver
        Document          Document // Access to existing DOM indexes and operations

        // Context for tracing and cancellation
        Context context.Context
}

// XPathFunction represents an XPath function implementation
type XPathFunction interface {
        Call(ctx *XPathContext, args []XPathValue) (XPathValue, error)
        MinArgs() int
        MaxArgs() int // -1 for unlimited
}

// XPath axis types matching XPath 1.0 specification
type XPathAxis uint8

const (
        XPathAxisChild             XPathAxis = iota
        XPathAxisDescendant
        XPathAxisParent
        XPathAxisAncestor
        XPathAxisFollowingSibling
        XPathAxisPrecedingSibling
        XPathAxisFollowing
        XPathAxisPreceding
        XPathAxisAttribute
        XPathAxisNamespace
        XPathAxisSelf
        XPathAxisDescendantOrSelf
        XPathAxisAncestorOrSelf
)

// XPathNodeTest represents node test conditions
type XPathNodeTest interface {
        Matches(node Node, ctx *XPathContext) bool
        Name() string
        IsWildcard() bool
}

// XPath operators for binary/unary expressions
type XPathOperator uint8

const (
        XPathOperatorOr    XPathOperator = iota
        XPathOperatorAnd
        XPathOperatorEq
        XPathOperatorNeq
        XPathOperatorLt
        XPathOperatorLte
        XPathOperatorGt
        XPathOperatorGte
        XPathOperatorPlus
        XPathOperatorMinus
        XPathOperatorMultiply
        XPathOperatorDiv
        XPathOperatorMod
        XPathOperatorUnion
        XPathOperatorUnaryMinus
)

// Concrete AST node implementations

// xpathAxisNode represents axis steps like child::element or descendant::*
type xpathAxisNode struct {
        axis       XPathAxis
        nodeTest   XPathNodeTest
        predicates []XPathNode
}

func (n xpathAxisNode) Type() XPathNodeType <span class="cov0" title="0">{ return XPathNodeTypeAxis }</span>

func (n xpathAxisNode) Evaluate(ctx *XPathContext) (XPathValue, error) <span class="cov0" title="0">{
        // Implementation will leverage existing DOM traversal methods
        // This is a placeholder for the actual axis evaluation
        return NewXPathNodeSetValue([]Node{}), nil
}</span>

// xpathLiteralNode represents string and number literals
type xpathLiteralNode struct {
        value XPathValue
}

func (n xpathLiteralNode) Type() XPathNodeType <span class="cov0" title="0">{ return XPathNodeTypeLiteral }</span>

func (n xpathLiteralNode) Evaluate(ctx *XPathContext) (XPathValue, error) <span class="cov0" title="0">{
        return n.value, nil
}</span>

// xpathBinaryOpNode represents binary operations like +, =, and, or
type xpathBinaryOpNode struct {
        operator    XPathOperator
        left, right XPathNode
}

func (n xpathBinaryOpNode) Type() XPathNodeType <span class="cov0" title="0">{ return XPathNodeTypeBinary }</span>

func (n xpathBinaryOpNode) Evaluate(ctx *XPathContext) (XPathValue, error) <span class="cov0" title="0">{
        // Implementation will handle all XPath 1.0 operators
        // This is a placeholder for the actual operation evaluation
        return NewXPathBooleanValue(false), nil
}</span>

// xpathFunctionNode represents function calls
type xpathFunctionNode struct {
        name string
        args []XPathNode
}

func (n xpathFunctionNode) Type() XPathNodeType <span class="cov0" title="0">{ return XPathNodeTypeFunction }</span>

func (n xpathFunctionNode) Evaluate(ctx *XPathContext) (XPathValue, error) <span class="cov0" title="0">{
        if fn, exists := ctx.FunctionLibrary[n.name]; exists </span><span class="cov0" title="0">{
                // Evaluate arguments
                argValues := make([]XPathValue, len(n.args))
                for i, arg := range n.args </span><span class="cov0" title="0">{
                        val, err := arg.Evaluate(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">argValues[i] = val</span>
                }
                <span class="cov0" title="0">return fn.Call(ctx, argValues)</span>
        }
        <span class="cov0" title="0">return nil, NewXPathError(XPathErrorTypeFunction, "Unknown function: "+n.name, 0)</span>
}

// XPathError represents XPath-specific errors
type XPathError struct {
        Type     XPathErrorType
        Message  string
        Position int
}

func (e *XPathError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewXPathError creates a new XPathError
func NewXPathError(errorType XPathErrorType, message string, position int) *XPathError <span class="cov0" title="0">{
        return &amp;XPathError{
                Type:     errorType,
                Message:  message,
                Position: position,
        }
}</span>

// NewXPathException creates a new XPath exception (alias for NewXPathError)
func NewXPathException(errorType string, message string) *XPathError <span class="cov0" title="0">{
        // Map string error types to XPathErrorType constants
        var errType XPathErrorType
        switch errorType </span>{
        case "INVALID_EXPRESSION_ERR":<span class="cov0" title="0">
                errType = XPathErrorTypeSyntax</span>
        case "TYPE_ERR":<span class="cov0" title="0">
                errType = XPathErrorTypeType</span>
        case "WRONG_DOCUMENT_ERR":<span class="cov0" title="0">
                errType = XPathErrorTypeContext</span>
        default:<span class="cov0" title="0">
                errType = XPathErrorTypeType</span>
        }
        <span class="cov0" title="0">return NewXPathError(errType, message, 0)</span>
}

// XPathErrorType represents different categories of XPath errors
type XPathErrorType uint8

const (
        XPathErrorTypeSyntax   XPathErrorType = iota
        XPathErrorTypeType
        XPathErrorTypeFunction
        XPathErrorTypeAxis
        XPathErrorTypeContext
)

// Helper functions for type conversions following XPath 1.0 spec

func stringToNumber(s string) float64 <span class="cov0" title="0">{
        // TODO: Implement XPath 1.0 string-to-number conversion rules
        // This is more complex than Go's standard conversion
        return 0
}</span>

func numberToString(n float64) string <span class="cov0" title="0">{
        // TODO: Implement XPath 1.0 number-to-string conversion rules
        return ""
}</span>

func booleanToString(b bool) string <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                return "true"
        }</span>
        <span class="cov0" title="0">return "false"</span>
}

func booleanToNumber(b bool) float64 <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func nodeSetToString(nodes []Node) string <span class="cov0" title="0">{
        // XPath 1.0: string value of node-set is string value of first node in document order
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(nodes[0].TextContent())</span>
}

func isNaN(f float64) bool <span class="cov0" title="0">{
        return f != f
}</span>

// ===========================================================================
// XPath Implementation Structures
// ===========================================================================

// xpathExpression implements XPathExpression interface
type xpathExpression struct {
        expression string
        resolver   XPathNSResolver
        ast        XPathNode
        document   *document
}

func (xe *xpathExpression) Evaluate(contextNode Node, resultType uint16, result XPathResult) (XPathResult, error) <span class="cov0" title="0">{
        if contextNode == nil </span><span class="cov0" title="0">{
                return nil, NewXPathException("TYPE_ERR", "Context node cannot be null")
        }</span>

        // Create evaluation context
        <span class="cov0" title="0">context := &amp;XPathContext{
                ContextNode:       contextNode,
                ContextSize:       1,
                ContextPosition:   1,
                VariableBindings:  make(map[string]XPathValue),
                FunctionLibrary:   getBuiltinFunctions(),
                NamespaceResolver: xe.resolver,
                Document:          xe.document,
        }

        // Evaluate AST
        value, err := xe.ast.Evaluate(context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewXPathException("TYPE_ERR", err.Error())
        }</span>

        // Convert to requested result type
        <span class="cov0" title="0">return xe.convertToResult(value, resultType, result)</span>
}

func (xe *xpathExpression) convertToResult(value XPathValue, resultType uint16, result XPathResult) (XPathResult, error) <span class="cov0" title="0">{
        switch resultType </span>{
        case XPATH_ANY_TYPE:<span class="cov0" title="0">
                // Return the most appropriate type
                switch value.(type) </span>{
                case xpathNodeSetValue:<span class="cov0" title="0">
                        return xe.convertToResult(value, XPATH_UNORDERED_NODE_ITERATOR_TYPE, result)</span>
                case xpathStringValue:<span class="cov0" title="0">
                        return xe.convertToResult(value, XPATH_STRING_TYPE, result)</span>
                case xpathNumberValue:<span class="cov0" title="0">
                        return xe.convertToResult(value, XPATH_NUMBER_TYPE, result)</span>
                case xpathBooleanValue:<span class="cov0" title="0">
                        return xe.convertToResult(value, XPATH_BOOLEAN_TYPE, result)</span>
                }
        case XPATH_STRING_TYPE:<span class="cov0" title="0">
                strVal := stringValueOf(value)
                return &amp;xpathStringResult{value: strVal}, nil</span>
        case XPATH_NUMBER_TYPE:<span class="cov0" title="0">
                numVal := numberValueOf(value)
                return &amp;xpathNumberResult{value: numVal}, nil</span>
        case XPATH_BOOLEAN_TYPE:<span class="cov0" title="0">
                boolVal := booleanValueOf(value)
                return &amp;xpathBooleanResult{value: boolVal}, nil</span>
        case XPATH_UNORDERED_NODE_ITERATOR_TYPE, XPATH_ORDERED_NODE_ITERATOR_TYPE:<span class="cov0" title="0">
                if nodeSet, ok := value.(xpathNodeSetValue); ok </span><span class="cov0" title="0">{
                        return &amp;xpathNodeIteratorResult{
                                nodes:        nodeSet.nodes,
                                currentIndex: -1,
                                resultType:   resultType,
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "Cannot convert to node iterator")</span>
        case XPATH_UNORDERED_NODE_SNAPSHOT_TYPE, XPATH_ORDERED_NODE_SNAPSHOT_TYPE:<span class="cov0" title="0">
                if nodeSet, ok := value.(xpathNodeSetValue); ok </span><span class="cov0" title="0">{
                        return &amp;xpathNodeSnapshotResult{
                                nodes:      nodeSet.nodes,
                                resultType: resultType,
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "Cannot convert to node snapshot")</span>
        case XPATH_ANY_UNORDERED_NODE_TYPE, XPATH_FIRST_ORDERED_NODE_TYPE:<span class="cov0" title="0">
                if nodeSet, ok := value.(xpathNodeSetValue); ok </span><span class="cov0" title="0">{
                        if len(nodeSet.nodes) &gt; 0 </span><span class="cov0" title="0">{
                                return &amp;xpathSingleNodeResult{
                                        node:       nodeSet.nodes[0],
                                        resultType: resultType,
                                }, nil
                        }</span>
                        <span class="cov0" title="0">return &amp;xpathSingleNodeResult{
                                node:       nil,
                                resultType: resultType,
                        }, nil</span>
                }
                <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "Cannot convert to single node")</span>
        }
        <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "Unsupported result type")</span>
}

// Helper functions for value conversion
func stringValueOf(value XPathValue) string <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case xpathStringValue:<span class="cov0" title="0">
                return v.value</span>
        case xpathNumberValue:<span class="cov0" title="0">
                return numberToString(v.value)</span>
        case xpathBooleanValue:<span class="cov0" title="0">
                return booleanToString(v.value)</span>
        case xpathNodeSetValue:<span class="cov0" title="0">
                return nodeSetToString(v.nodes)</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func numberValueOf(value XPathValue) float64 <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case xpathStringValue:<span class="cov0" title="0">
                return stringToNumber(v.value)</span>
        case xpathNumberValue:<span class="cov0" title="0">
                return v.value</span>
        case xpathBooleanValue:<span class="cov0" title="0">
                return booleanToNumber(v.value)</span>
        case xpathNodeSetValue:<span class="cov0" title="0">
                return stringToNumber(nodeSetToString(v.nodes))</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func booleanValueOf(value XPathValue) bool <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case xpathStringValue:<span class="cov0" title="0">
                return v.value != ""</span>
        case xpathNumberValue:<span class="cov0" title="0">
                return v.value != 0 &amp;&amp; !isNaN(v.value)</span>
        case xpathBooleanValue:<span class="cov0" title="0">
                return v.value</span>
        case xpathNodeSetValue:<span class="cov0" title="0">
                return len(v.nodes) &gt; 0</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ===========================================================================
// XPath Result Implementations
// ===========================================================================

// xpathStringResult implements XPathResult for string values
type xpathStringResult struct {
        value string
}

func (r *xpathStringResult) ResultType() uint16 <span class="cov0" title="0">{
        return XPATH_STRING_TYPE
}</span>

func (r *xpathStringResult) NumberValue() (float64, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a number")
}</span>

func (r *xpathStringResult) StringValue() (string, error) <span class="cov0" title="0">{
        return r.value, nil
}</span>

func (r *xpathStringResult) BooleanValue() (bool, error) <span class="cov0" title="0">{
        return false, NewXPathException("TYPE_ERR", "Result is not a boolean")
}</span>

func (r *xpathStringResult) SingleNodeValue() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a node")
}</span>

func (r *xpathStringResult) InvalidIteratorState() bool <span class="cov0" title="0">{
        return false
}</span>

func (r *xpathStringResult) SnapshotLength() (uint32, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

func (r *xpathStringResult) IterateNext() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not an iterator")
}</span>

func (r *xpathStringResult) SnapshotItem(index uint32) (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

// xpathNumberResult implements XPathResult for numeric values
type xpathNumberResult struct {
        value float64
}

func (r *xpathNumberResult) ResultType() uint16 <span class="cov0" title="0">{
        return XPATH_NUMBER_TYPE
}</span>

func (r *xpathNumberResult) NumberValue() (float64, error) <span class="cov0" title="0">{
        return r.value, nil
}</span>

func (r *xpathNumberResult) StringValue() (string, error) <span class="cov0" title="0">{
        return "", NewXPathException("TYPE_ERR", "Result is not a string")
}</span>

func (r *xpathNumberResult) BooleanValue() (bool, error) <span class="cov0" title="0">{
        return false, NewXPathException("TYPE_ERR", "Result is not a boolean")
}</span>

func (r *xpathNumberResult) SingleNodeValue() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a node")
}</span>

func (r *xpathNumberResult) InvalidIteratorState() bool <span class="cov0" title="0">{
        return false
}</span>

func (r *xpathNumberResult) SnapshotLength() (uint32, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

func (r *xpathNumberResult) IterateNext() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not an iterator")
}</span>

func (r *xpathNumberResult) SnapshotItem(index uint32) (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

// xpathBooleanResult implements XPathResult for boolean values
type xpathBooleanResult struct {
        value bool
}

func (r *xpathBooleanResult) ResultType() uint16 <span class="cov0" title="0">{
        return XPATH_BOOLEAN_TYPE
}</span>

func (r *xpathBooleanResult) NumberValue() (float64, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a number")
}</span>

func (r *xpathBooleanResult) StringValue() (string, error) <span class="cov0" title="0">{
        return "", NewXPathException("TYPE_ERR", "Result is not a string")
}</span>

func (r *xpathBooleanResult) BooleanValue() (bool, error) <span class="cov0" title="0">{
        return r.value, nil
}</span>

func (r *xpathBooleanResult) SingleNodeValue() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a node")
}</span>

func (r *xpathBooleanResult) InvalidIteratorState() bool <span class="cov0" title="0">{
        return false
}</span>

func (r *xpathBooleanResult) SnapshotLength() (uint32, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

func (r *xpathBooleanResult) IterateNext() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not an iterator")
}</span>

func (r *xpathBooleanResult) SnapshotItem(index uint32) (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

// xpathSingleNodeResult implements XPathResult for single node values
type xpathSingleNodeResult struct {
        node       Node
        resultType uint16
}

func (r *xpathSingleNodeResult) ResultType() uint16 <span class="cov0" title="0">{
        return r.resultType
}</span>

func (r *xpathSingleNodeResult) NumberValue() (float64, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a number")
}</span>

func (r *xpathSingleNodeResult) StringValue() (string, error) <span class="cov0" title="0">{
        return "", NewXPathException("TYPE_ERR", "Result is not a string")
}</span>

func (r *xpathSingleNodeResult) BooleanValue() (bool, error) <span class="cov0" title="0">{
        return false, NewXPathException("TYPE_ERR", "Result is not a boolean")
}</span>

func (r *xpathSingleNodeResult) SingleNodeValue() (Node, error) <span class="cov0" title="0">{
        return r.node, nil
}</span>

func (r *xpathSingleNodeResult) InvalidIteratorState() bool <span class="cov0" title="0">{
        return false
}</span>

func (r *xpathSingleNodeResult) SnapshotLength() (uint32, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

func (r *xpathSingleNodeResult) IterateNext() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not an iterator")
}</span>

func (r *xpathSingleNodeResult) SnapshotItem(index uint32) (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

// xpathNodeIteratorResult implements XPathResult for node iterator values
type xpathNodeIteratorResult struct {
        nodes        []Node
        currentIndex int
        resultType   uint16
}

func (r *xpathNodeIteratorResult) ResultType() uint16 <span class="cov0" title="0">{
        return r.resultType
}</span>

func (r *xpathNodeIteratorResult) NumberValue() (float64, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a number")
}</span>

func (r *xpathNodeIteratorResult) StringValue() (string, error) <span class="cov0" title="0">{
        return "", NewXPathException("TYPE_ERR", "Result is not a string")
}</span>

func (r *xpathNodeIteratorResult) BooleanValue() (bool, error) <span class="cov0" title="0">{
        return false, NewXPathException("TYPE_ERR", "Result is not a boolean")
}</span>

func (r *xpathNodeIteratorResult) SingleNodeValue() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a single node")
}</span>

func (r *xpathNodeIteratorResult) InvalidIteratorState() bool <span class="cov0" title="0">{
        // TODO: Check for document mutations that would invalidate iterator
        return false
}</span>

func (r *xpathNodeIteratorResult) SnapshotLength() (uint32, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

func (r *xpathNodeIteratorResult) IterateNext() (Node, error) <span class="cov0" title="0">{
        r.currentIndex++
        if r.currentIndex &gt;= len(r.nodes) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return r.nodes[r.currentIndex], nil</span>
}

func (r *xpathNodeIteratorResult) SnapshotItem(index uint32) (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a snapshot")
}</span>

// xpathNodeSnapshotResult implements XPathResult for node snapshot values
type xpathNodeSnapshotResult struct {
        nodes      []Node
        resultType uint16
}

func (r *xpathNodeSnapshotResult) ResultType() uint16 <span class="cov0" title="0">{
        return r.resultType
}</span>

func (r *xpathNodeSnapshotResult) NumberValue() (float64, error) <span class="cov0" title="0">{
        return 0, NewXPathException("TYPE_ERR", "Result is not a number")
}</span>

func (r *xpathNodeSnapshotResult) StringValue() (string, error) <span class="cov0" title="0">{
        return "", NewXPathException("TYPE_ERR", "Result is not a string")
}</span>

func (r *xpathNodeSnapshotResult) BooleanValue() (bool, error) <span class="cov0" title="0">{
        return false, NewXPathException("TYPE_ERR", "Result is not a boolean")
}</span>

func (r *xpathNodeSnapshotResult) SingleNodeValue() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not a single node")
}</span>

func (r *xpathNodeSnapshotResult) InvalidIteratorState() bool <span class="cov0" title="0">{
        return false
}</span>

func (r *xpathNodeSnapshotResult) SnapshotLength() (uint32, error) <span class="cov0" title="0">{
        return uint32(len(r.nodes)), nil
}</span>

func (r *xpathNodeSnapshotResult) IterateNext() (Node, error) <span class="cov0" title="0">{
        return nil, NewXPathException("TYPE_ERR", "Result is not an iterator")
}</span>

func (r *xpathNodeSnapshotResult) SnapshotItem(index uint32) (Node, error) <span class="cov0" title="0">{
        if index &gt;= uint32(len(r.nodes)) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return r.nodes[index], nil</span>
}

// ===========================================================================
// Built-in Functions
// ===========================================================================

// getBuiltinFunctions returns the standard XPath 1.0 built-in functions
func getBuiltinFunctions() map[string]XPathFunction <span class="cov0" title="0">{
        return map[string]XPathFunction{
                // Node set functions
                "last": &amp;xpathBuiltinFunction{
                        name:    "last",
                        minArgs: 0,
                        maxArgs: 0,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) </span><span class="cov0" title="0">{
                                return NewXPathNumberValue(float64(context.ContextSize)), nil
                        }</span>,
                },
                "position": &amp;xpathBuiltinFunction{
                        name:    "position",
                        minArgs: 0,
                        maxArgs: 0,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                return NewXPathNumberValue(float64(context.ContextPosition)), nil
                        }</span>,
                },
                "count": &amp;xpathBuiltinFunction{
                        name:    "count",
                        minArgs: 1,
                        maxArgs: 1,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                if nodeSet, ok := args[0].(xpathNodeSetValue); ok </span><span class="cov0" title="0">{
                                        return NewXPathNumberValue(float64(len(nodeSet.nodes))), nil
                                }</span>
                                <span class="cov0" title="0">return nil, NewXPathException("TYPE_ERR", "count() argument must be a node-set")</span>
                        },
                },
                // String functions
                "string": &amp;xpathBuiltinFunction{
                        name:    "string",
                        minArgs: 0,
                        maxArgs: 1,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                if len(args) == 0 </span><span class="cov0" title="0">{
                                        // Convert context node to string
                                        strVal := context.ContextNode.TextContent()
                                        return NewXPathStringValue(string(strVal)), nil
                                }</span>
                                <span class="cov0" title="0">strVal := stringValueOf(args[0])
                                return NewXPathStringValue(strVal), nil</span>
                        },
                },
                // Number functions
                "number": &amp;xpathBuiltinFunction{
                        name:    "number",
                        minArgs: 0,
                        maxArgs: 1,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                if len(args) == 0 </span><span class="cov0" title="0">{
                                        // Convert context node to number
                                        strVal := context.ContextNode.TextContent()
                                        numVal := stringToNumber(string(strVal))
                                        return NewXPathNumberValue(numVal), nil
                                }</span>
                                <span class="cov0" title="0">numVal := numberValueOf(args[0])
                                return NewXPathNumberValue(numVal), nil</span>
                        },
                },
                // Boolean functions
                "boolean": &amp;xpathBuiltinFunction{
                        name:    "boolean",
                        minArgs: 1,
                        maxArgs: 1,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                boolVal := booleanValueOf(args[0])
                                return NewXPathBooleanValue(boolVal), nil
                        }</span>,
                },
                "not": &amp;xpathBuiltinFunction{
                        name:    "not",
                        minArgs: 1,
                        maxArgs: 1,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                boolVal := booleanValueOf(args[0])
                                return NewXPathBooleanValue(!boolVal), nil
                        }</span>,
                },
                "true": &amp;xpathBuiltinFunction{
                        name:    "true",
                        minArgs: 0,
                        maxArgs: 0,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                return NewXPathBooleanValue(true), nil
                        }</span>,
                },
                "false": &amp;xpathBuiltinFunction{
                        name:    "false",
                        minArgs: 0,
                        maxArgs: 0,
                        impl: func(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
                                return NewXPathBooleanValue(false), nil
                        }</span>,
                },
        }
}

// xpathBuiltinFunction implements XPathFunction for built-in functions
type xpathBuiltinFunction struct {
        name    string
        minArgs int
        maxArgs int
        impl    func(*XPathContext, []XPathValue) (XPathValue, error)
}

func (f *xpathBuiltinFunction) Call(context *XPathContext, args []XPathValue) (XPathValue, error) <span class="cov0" title="0">{
        if len(args) &lt; f.minArgs || (f.maxArgs != -1 &amp;&amp; len(args) &gt; f.maxArgs) </span><span class="cov0" title="0">{
                return nil, NewXPathException("TYPE_ERR", fmt.Sprintf("%s() requires %d to %d arguments, got %d", f.name, f.minArgs, f.maxArgs, len(args)))
        }</span>
        <span class="cov0" title="0">return f.impl(context, args)</span>
}

func (f *xpathBuiltinFunction) MinArgs() int <span class="cov0" title="0">{
        return f.minArgs
}</span>

func (f *xpathBuiltinFunction) MaxArgs() int <span class="cov0" title="0">{
        return f.maxArgs
}</span>

// ===========================================================================
// XPath Parser Stub
// ===========================================================================

// NewXPathParser creates a new XPath parser
func NewXPathParser() *XPathParser <span class="cov0" title="0">{
        return &amp;XPathParser{}
}</span>

// XPathParser parses XPath expressions into AST
type XPathParser struct {}

// Parse parses an XPath expression string into an AST
func (p *XPathParser) Parse(expression string) (XPathNode, error) <span class="cov0" title="0">{
        // TODO: Implement full XPath 1.0 parser
        // For now, return a simple stub that handles basic cases
        
        if expression == "" </span><span class="cov0" title="0">{
                return nil, NewXPathException("INVALID_EXPRESSION_ERR", "Empty expression")
        }</span>
        
        // Very basic parsing - just handle simple cases for now
        <span class="cov0" title="0">switch </span>{
        case expression[0] == '/' &amp;&amp; len(expression) == 1:<span class="cov0" title="0">
                // Root node selection - return a simple axis node
                return &amp;xpathAxisNode{
                        axis:       XPathAxisSelf,
                        nodeTest:   &amp;basicNodeTest{name: "node()"},
                        predicates: []XPathNode{},
                }, nil</span>
        case expression[0] == '/':<span class="cov0" title="0">
                // Absolute path - simple element selection
                path := expression[1:]
                return &amp;xpathAxisNode{
                        axis:       XPathAxisChild,
                        nodeTest:   &amp;basicNodeTest{name: path},
                        predicates: []XPathNode{},
                }, nil</span>
        default:<span class="cov0" title="0">
                // Relative path or other expression
                // For now, treat as element name
                return &amp;xpathAxisNode{
                        axis:       XPathAxisChild,
                        nodeTest:   &amp;basicNodeTest{name: expression},
                        predicates: []XPathNode{},
                }, nil</span>
        }
}

// basicNodeTest is a simple implementation of XPathNodeTest
type basicNodeTest struct {
        name string
}

func (nt *basicNodeTest) Matches(node Node, ctx *XPathContext) bool <span class="cov0" title="0">{
        // Very basic matching - just match element names
        if nt.name == "node()" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if nt.name == "*" </span><span class="cov0" title="0">{
                return node.NodeType() == ELEMENT_NODE
        }</span>
        <span class="cov0" title="0">return node.NodeType() == ELEMENT_NODE &amp;&amp; string(node.NodeName()) == nt.name</span>
}

func (nt *basicNodeTest) Name() string <span class="cov0" title="0">{
        return nt.name
}</span>

func (nt *basicNodeTest) IsWildcard() bool <span class="cov0" title="0">{
        return nt.name == "*" || nt.name == "node()"
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
